<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Lua学习总结</title>
      <link href="/2023/09/06/Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2023/09/06/Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作一直在写 Lua 相关的游戏逻辑脚本，但一直没做个总结，前端时间看了一下 Lua 语言的底层逻辑，做个记录总结让以后可以拿出来翻翻看。文章有点长，可以通过索引查找对应内容。</p><hr><h2 id="Lua-的底层与编译"><a href="#Lua-的底层与编译" class="headerlink" title="Lua 的底层与编译"></a>Lua 的底层与编译</h2><h3 id="语言类型与区别"><a href="#语言类型与区别" class="headerlink" title="语言类型与区别"></a>语言类型与区别</h3><p>Lua 语言是以 C 语言为底层的<code>脚本语言</code>（动态语言，运行时编译），与 C 语言，C++等<code>静态语言</code>（静态语言，运行前编译）不同。其中 Lua 的执行主要运行流程如下：</p><ul><li>程序员编辑 Lua 脚本代码，保存.lua 文件</li><li>语法词法分析，并生成指令集（*lua.byte 文件），属于编译过程</li><li>Lua 虚拟机执行指令集，属于执行过程</li><li>输出结果</li></ul><p>这里放一张由大佬（<strong>烟雨迷离半世殇</strong>）做的对比表格：</p><table><thead><tr><th>语言</th><th>编辑</th><th>预编译</th><th>运行时编译</th><th>执行</th></tr></thead><tbody><tr><td>Lua</td><td>编写 lua 文件</td><td>无</td><td>虚拟机读取字节码并转换成虚拟机指令，汇编器编译成机器码</td><td>CPU 执行机器码</td></tr><tr><td>C#</td><td>编写 cs 文件</td><td>被 C#编译器编译成 dll，包含 IL 代码</td><td>CLR 使用 JIT 编译把 IL 转换成机器码</td><td>CPU 执行机器码</td></tr></tbody></table><h3 id="Lua-语言编译原理"><a href="#Lua-语言编译原理" class="headerlink" title="Lua 语言编译原理"></a>Lua 语言编译原理</h3><p>Lua 语言的的编译，首先需要明白代码块（chunk），闭包（closure），和原型（proto）的关系。</p><ol><li>chunk：代码块，一段符合 Lua 语法的代码。</li><li>closure：Lua 运行期间的一个实例对象，在运行期间调用的大多是一个 closure。</li><li>proto：（原型）Lua 语言中 closure 的原型（类似与 C++中对象声明与实例的关系），定义了有关代码段的大部分信息，包括：<ul><li>指令列表：包含了函数编译后生成的<code>虚拟机指令</code>。</li><li>常量表：这个函数运行期需要的<code>所有常量</code>，在指令中，常量使用常量表 id 进行索引。</li><li>子 proto 表：所有内嵌于这个函数的<code>proto列表</code>，在 OP_CLOSURE 指令中的 proto id 就是索引的这个表。</li><li>局部变量描述：这个函数使用到的<code>所有局部变量名称，以及生命期</code>。由于<code>所有的局部变量运行期都被转化成了寄存器id</code>，所以这些信息只是 debug 使用。</li><li>Upvalue 描述：upvalue 是内嵌函数中能够访问到的外包函数中的局部变量；称为外部局部变量感觉更为贴切。在创建 closure 时（创建函数实例）初始化 Upvalue。</li></ul></li></ol><p>每一个 proto 在运行期间可以产生多个 closure 对象来表示函数实例。</p><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled.png" alt="Untitled"></p><p>**<code>closure是运行期的对象</code>**，与运行期关系更大；而<code>与编译期相关的其实是proto对象</code>，他才是编译过程真正需要生成的目标对象。</p><h3 id="Lua-语言编译流程"><a href="#Lua-语言编译流程" class="headerlink" title="Lua 语言编译流程"></a>Lua 语言编译流程</h3><ul><li>首先调用<code>lua_load</code> api，将一块符合 lua 语法的代码块<code>Chunk</code>进行编译。</li><li>编译为当前的 Chunk 生成一个<code>mainfunc proto</code>对象，并生成一个父对象<code>mainfunc closure</code>对象放到当前的栈顶中，等待接下来的执行。</li><li>Chunk 内部的每个<code>function statement（函数语句）</code>也都会生成一个对应的<code>子proto</code>，保存在外层函数的子函数列表中（proto 中有子 proto 列表）。</li><li>所有最外层的**<code>function statement</code>**的 proto 会被保存到<code>mainfunc proto</code>的子函数列表中。</li><li>按照层次依次编译，形成一个以<code>mainfunc</code>为根节点的 proto 树。</li></ul><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled1.png" alt="Untitled"></p><hr><h2 id="Lua-的底层数据结构"><a href="#Lua-的底层数据结构" class="headerlink" title="Lua 的底层数据结构"></a>Lua 的底层数据结构</h2><p>只要讲到有关于 Lua 与其他语言交互的过程的相关原理，虚拟机一定是一个不可能绕过的概念。需要注意的是不同于像**<code>C#，java等语言使用的是基于堆栈的虚拟机</code>**，Lua5.0 之后，<code>**Lua语言开始改用基于寄存器的虚拟机</code>。**首先了解一下，Lua 底层数据结构的实现方式。</p><h3 id="C-语言的实现面向对象（注意可能存在-Lua-版本差异）"><a href="#C-语言的实现面向对象（注意可能存在-Lua-版本差异）" class="headerlink" title="C 语言的实现面向对象（注意可能存在 Lua 版本差异）"></a>C 语言的实现面向对象（注意可能存在 Lua 版本差异）</h3><p>由于 Lua 的底层是通过 C 语言进行实现的，所以在设置 Lua 的数据结构的时候，也是通过 C 语言来进行实现。而主要的实现思路是：</p><ul><li>定义一个公共的数据结构作为基础类型，用来存储表达数据的基础信息，其他类型由此派生（<strong>需要注意的是这个基础类型需要包含所有数据的存储方式，通过 Union 进行实现</strong>）。</li><li>使用联合（ union ）来将所有数据包进来，<ul><li><strong>Value</strong>提供基础数据的存储方式（GC 对象，指针，number 与布朗值）以及<strong>GCObject</strong>。</li><li><strong>GCObject</strong>提供所有非基础类型的存储方式（table，string，closure 等），需要进行垃圾回收</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lua_TValue</span> &#123;</span></span><br><span class="line">  Value value_;</span><br><span class="line">  <span class="type">int</span> tt_;         <span class="comment">//数据类型标识，新版11种（下截图），同时使用TValuefields进行表示</span></span><br><span class="line">&#125; TValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">GCObject *gc;    <span class="comment">//上述所有需要进行数据回收的联合体，指针，指向联合体GCObject定义（table，thread，closure等）</span></span><br><span class="line"><span class="type">void</span> *p;         <span class="comment">//轻量级light，userdata，指针</span></span><br><span class="line">lua_CFunction f; <span class="comment">//旧版没有这个。C语言函数</span></span><br><span class="line">lua_Integer i;   <span class="comment">//整形类型，Lua5.1版本中只使用了lua_Number来进行整数和浮点数表示，但范围比int64_t类型小，之后Lua5.3扩充了整形类型来表示整数</span></span><br><span class="line">lua_Number n;    <span class="comment">//默认为double类型，Lua重编译可更换</span></span><br><span class="line"><span class="type">int</span> b;           <span class="comment">//boolean值</span></span><br><span class="line">&#125;Value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部包括table，string，usedata等定义</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">GCObject</span>&#123;</span></span><br><span class="line">GCheader gch;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">UTString</span> <span class="title">ts</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Udata</span> <span class="title">u</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Closure</span> <span class="title">cl</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Table</span> <span class="title">h</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> <span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UpVal</span> <span class="title">uv</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> <span class="title">th</span>;</span> <span class="comment">/*thread*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下不涉及数据结构表示，只是垃圾回收GC相关定义</span></span><br><span class="line"><span class="comment">//GCheader结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GCheader</span>&#123;</span></span><br><span class="line">CommonHeader;</span><br><span class="line">&#125; GCheader;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CommonHeader定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CommonHeader GCObject *next;lu_byte tt;lu_byte marked</span></span><br><span class="line"><span class="comment">//next:下一个GC链表的成员</span></span><br><span class="line"><span class="comment">//tt：表示数据的类型，即上文图表2.1中的相关类型宏定义</span></span><br><span class="line"><span class="comment">//marked：GC相关标记位</span></span><br></pre></td></tr></table></figure><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled2.png" alt="Untitled.png"></p><p>综上所述，Lua 中的数据结构是基于<strong>TValue</strong>来进行表示的。需要注意的是<strong>Value</strong>中存在的指针*p 是用来存储数据结构 lightusedate（自定义类型），而<strong>GCObject</strong>中的的对象是用来存储 usedate（自定义类型）对象，分别对应上图（数据结构）中的类型 2 与类型 7。这也表示了**<code>usedate会由Lua自动进行回收，但是lightusedate需要程序员自己进行管理</code>**。有上述代码可以得出结论：</p><ul><li>number、boolean、nil、light userdata 四种类型的值是直接存在栈上元素里的，和垃圾回收无关。</li><li>string、table、closure、userdata、thread 等存在栈上元素里的只是指针，数据在堆中他们都会在生命周期结束后被垃圾回收。</li><li>function 类型的存储，通过上述编译原理部分内容以及<strong>GCObject</strong>的 Proto 与 Closure 进行实现</li></ul><h3 id="数据结构：表-Table"><a href="#数据结构：表-Table" class="headerlink" title="数据结构：表 Table"></a>数据结构：表 Table</h3><p>Lua 中的数据结构中，表 Table 是最重要的一种。在逻辑上是一个关联数组（哈希表，实际上是有一个哈希表与数组组成），<code>可以通过任何值（除了 nil）来索引表项，表项可以存储任何类型的值</code>。原因可以看一下存储在<strong>GCObject</strong>中的 struct 表 table 的代码结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">CommonHeader;</span><br><span class="line">lu_byte flags; <span class="comment">//元方法存在标记，标记为1，表示元方法不存在</span></span><br><span class="line">lu_byte lsizenode; <span class="comment">//散列桶数组的大小的 log2(size)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Table</span> <span class="title">netatable</span>;</span> <span class="comment">//元表</span></span><br><span class="line">TValue *<span class="built_in">array</span>; <span class="comment">//指针，指向数组表，数组表中的数据，起始键为1</span></span><br><span class="line">Node *node; <span class="comment">//散列桶起始指针</span></span><br><span class="line">Node *lastfree; <span class="comment">//散列桶末尾指针</span></span><br><span class="line">GCObject *gclist; <span class="comment">//GC相关的链表</span></span><br><span class="line"><span class="type">int</span> sizearray; <span class="comment">//数组表的长度</span></span><br><span class="line">&#125; Table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//table中node所包含的数据与结构（如上图表所示）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">Tkey</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">TValuefield;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;nk;</span><br><span class="line">Tvalue tvk;</span><br><span class="line">&#125;Tkey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">TValue i_val;</span><br><span class="line">Tkey i_key;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled3.png" alt="Untitled"></p><p>有上图以及逻辑代码可以看出：</p><ul><li>Table 的数据存储分为两个部分：所有键值在 1 与 n（上限）之间的数据存储在数组表中，非整数键值或超过键值表示范围的通过散列表进行存储。（这就是 Lua 中迭代器<code>pair与ipair遍历的区别</code>原理）</li><li>数据存储通过 TValue 类型进行存储的。这表示表中可以存放所有的 Lua 数据结构。</li><li>表**<code>netatable</code>**与标记<code>flags</code>实现了元表元方法的相关功能。</li></ul><p>除了以上可以由结构看出的内容之外，有关于表的存储内容相关的部分也需要注意：</p><ul><li>Table 的存储的动态的，也就是数组表与散列表的大小是可以进行动态变化的（动态扩容）。</li><li>最初表的两个部分，都是空的，表的扩容需要 Lua 重新计算散列表与数组表的大小，找到满足一下条件的最大 n 值作为长度：**<code>1到 n 之间至少一半的空间会被利用</code><strong>（避免像稀疏数组一样浪费空间）；</strong><code>并且 n/2+1到 n 之间的空间至少有一个空间被利用</code>**（避免 n/2 个空间就能容纳所有数据时申请 n 个空间而造成浪费）</li><li>Lua 并非在空间上直接增加表大小（结构非链表，不能直接增加节点），而是申请新的空间，并将元数据存放到新空间中。</li><li>表的两个存储部分：数组表与散列表是分开扩容的。这种混合型结构让表在作为数组使用时，有数组的优点（存储紧凑，性能高，键值隐含，不用在意哈希表的空间与计算开销）。作为散列表使用时，数组部分又常常不存在，从而节省内存空间。</li></ul><p>PS：除了以上表述内容之外，Table 数据结构的散列表部分还使用了双重散列技术，又叫双重哈希法，有兴趣可以查找一下相关资料以及 Brent 论文提到的 HashTable 增查新方法 （地址在最后参考文献中）。</p><h3 id="数据结构：字符串-String"><a href="#数据结构：字符串-String" class="headerlink" title="数据结构：字符串 String"></a>数据结构：字符串 String</h3><p>字符串 String 类型与本身是结构体的 table 类似。它本身是 union 联合提结构，底层代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//长短字符串定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TSHRSTR (LUA_TSTRING | (0 &lt;&lt; 4))  <span class="comment">/* short strings */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TLNGSTR (LUA_TSTRING | (1 &lt;&lt; 4))  <span class="comment">/* long strings */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.2版本，区分长短字符串</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte extra;  <span class="comment">/* reserved words for short strings; &quot;has hash&quot; for longs */</span></span><br><span class="line">                  <span class="comment">/* 对于短字符串：这个标示是否是保留字，长字符串：是否已经哈希① */</span></span><br><span class="line">  lu_byte shrlen;  <span class="comment">/* 短字符串的长度 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> hash;<span class="comment">//hash值</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> lnglen;  <span class="comment">/* 长字符串的长度 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> *<span class="title">hnext</span>;</span>  <span class="comment">//哈希表的链表</span></span><br><span class="line">  &#125; u;</span><br><span class="line">&#125; TString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">UTString</span> &#123;</span></span><br><span class="line">  L_Umaxalign dummy;  <span class="comment">/* 内存对齐 */</span></span><br><span class="line">  TString tsv;</span><br><span class="line">&#125; UTString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stringtable</span> &#123;</span></span><br><span class="line">GCObject **hash;</span><br><span class="line">lu_int32 nuse; <span class="comment">/* number of elements */</span></span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line">&#125; stringtable;</span><br></pre></td></tr></table></figure><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled4.png" alt="Untitled"></p><p>在 Lua5.2 之后，字符串存储就被分成了两种：长字符串与短字符串。</p><ul><li>短字符串存储在<code>全局stringtable</code>当中，相同字符串只会有一份实际数据拷贝，每份相同的 TString 对象只是存放一个 hash 值，用来索引 stringtable。</li><li>长字符串直接存储在 union 的<code>hnext</code>当中，相同字符串在内存都是单独一份数据拷贝。</li><li>为了避免链表中数据过多导致的可能的一次线性查找过程，除了长字符串单独存储外，还有 luaS_resize(lua_State *L,int newsize)专门进行重新的散列排列，通常在以下两种情况调用：<ul><li>lgc.c 的 checkSizes 函数：散列桶数量太大（是实际存放的字符串 4 倍），减少为原本一倍</li><li>lstring.c 的 newlstr 函数：字符串数量太大（字符串数量大于桶数量，并且桶数组的数量小于 MAX_INT/2）,对桶进行翻倍扩容</li></ul></li></ul><h3 id="数据结构：thread（叫线程，是协程）"><a href="#数据结构：thread（叫线程，是协程）" class="headerlink" title="数据结构：thread（叫线程，是协程）"></a>数据结构：thread（叫线程，是协程）</h3><p>Lua 5.0 版开始， <code>Lua 实现不对称协程</code>（也称为半不对称协程或不完全协程） 。</p><p>Lua 将所有关于协同程序的函数放置在一个名为“coroutine”的 table 中。</p><ol><li>coroutine.create 创建一个 thread 类型的值表示新的协同程序，返回一个协同程序。</li><li>coroutine.status 检查协同程序的状态（挂起 suspended、运行 running、死亡 dead、正常 normal）。</li><li>coroutine.resume 启动或再次启动一个协同程序，并将其状态由挂起改为运行。</li><li>coroutine.yield 让一个协同程序挂起。</li><li>coroutine.wrap 同样创建一个新的协同程序，返回一个函数。</li></ol><p>Lua 中协程是有栈的，这样我们就可以在多级函数嵌套调用内挂起（暂停执行）一个协程。解释器只是简单地将整个栈放在一边而在另一个栈上继续执行。 一个程序可以任意重启任何挂起的协程。当与栈相关的协程不可用时，垃圾回收器就回收栈空间。</p><hr><h2 id="Lua-虚拟机的跨语言调用"><a href="#Lua-虚拟机的跨语言调用" class="headerlink" title="Lua 虚拟机的跨语言调用"></a>Lua 虚拟机的跨语言调用</h2><p>Lua 提供了一个虚拟栈，这个虚拟栈可以完成 Lua 语言与其他语言之间的数据交换。Lua API 本身提供了一系列接口可以让我们操作这个虚拟栈。</p><p>以下是 C 语言对虚拟栈的操作 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** push functions (C -&gt; stack)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//数据从C语言到虚拟栈中</span></span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushnil)</span> <span class="params">(lua_State *L)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushnumber)</span> <span class="params">(lua_State *L, lua_Number n)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushinteger)</span> <span class="params">(lua_State *L, lua_Integer n)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushlstring)</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> l)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushstring)</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">char</span> *(lua_pushvfstring) (lua_State *L, <span class="type">const</span> <span class="type">char</span> *fmt,</span><br><span class="line">                                                      va_list argp);</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">char</span> *(lua_pushfstring) (lua_State *L, <span class="type">const</span> <span class="type">char</span> *fmt, ...);</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushcclosure)</span> <span class="params">(lua_State *L, lua_CFunction fn, <span class="type">int</span> n)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushboolean)</span> <span class="params">(lua_State *L, <span class="type">int</span> b)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushlightuserdata)</span> <span class="params">(lua_State *L, <span class="type">void</span> *p)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>   <span class="params">(lua_pushthread)</span> <span class="params">(lua_State *L)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据由虚拟栈到C语言中</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** access functions (stack -&gt; C)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LUA_API <span class="title function_">int</span>             <span class="params">(lua_isnumber)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>             <span class="params">(lua_isstring)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>             <span class="params">(lua_iscfunction)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>             <span class="params">(lua_isuserdata)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>             <span class="params">(lua_type)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">char</span>     *(lua_typename) (lua_State *L, <span class="type">int</span> tp);</span><br><span class="line"></span><br><span class="line">LUA_API <span class="title function_">int</span>            <span class="params">(lua_equal)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx1, <span class="type">int</span> idx2)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>            <span class="params">(lua_rawequal)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx1, <span class="type">int</span> idx2)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>            <span class="params">(lua_lessthan)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx1, <span class="type">int</span> idx2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经实测，to* 函数不会出栈</span></span><br><span class="line">LUA_API <span class="title function_">lua_Number</span>      <span class="params">(lua_tonumber)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">lua_Integer</span>     <span class="params">(lua_tointeger)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>             <span class="params">(lua_toboolean)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">char</span>     *(lua_tolstring) (lua_State *L, <span class="type">int</span> idx, <span class="type">size_t</span> *len);</span><br><span class="line">LUA_API <span class="title function_">size_t</span>          <span class="params">(lua_objlen)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">lua_CFunction</span>   <span class="params">(lua_tocfunction)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="type">void</span>           *(lua_touserdata) (lua_State *L, <span class="type">int</span> idx);</span><br><span class="line">LUA_API lua_State      *(lua_tothread) (lua_State *L, <span class="type">int</span> idx);</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">void</span>     *(lua_topointer) (lua_State *L, <span class="type">int</span> idx);</span><br></pre></td></tr></table></figure><p>以下是 Lua 对虚拟栈的操作 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** get functions (Lua -&gt; stack)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//Lua数据入栈</span></span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_gettable)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_getfield)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, <span class="type">const</span> <span class="type">char</span> *k)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_rawget)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_rawgeti)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, <span class="type">int</span> n)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_createtable)</span> <span class="params">(lua_State *L, <span class="type">int</span> narr, <span class="type">int</span> nrec)</span>;</span><br><span class="line">LUA_API <span class="type">void</span> *(lua_newuserdata) (lua_State *L, <span class="type">size_t</span> sz);</span><br><span class="line">LUA_API <span class="title function_">int</span>   <span class="params">(lua_getmetatable)</span> <span class="params">(lua_State *L, <span class="type">int</span> objindex)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_getfenv)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** set functions (stack -&gt; Lua)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//Lua获取栈中数据或修改栈中数据</span></span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_settable)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_setfield)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, <span class="type">const</span> <span class="type">char</span> *k)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_rawset)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_rawseti)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, <span class="type">int</span> n)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>   <span class="params">(lua_setmetatable)</span> <span class="params">(lua_State *L, <span class="type">int</span> obj</span></span><br></pre></td></tr></table></figure><p>除此之外，还有一系列用来控制堆栈的相关函数（栈操作）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** basic stack manipulation</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LUA_API <span class="title function_">int</span>   <span class="params">(lua_gettop)</span> <span class="params">(lua_State *L)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_settop)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushvalue)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_remove)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_insert)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_replace)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>   <span class="params">(lua_checkstack)</span> <span class="params">(lua_State *L, <span class="type">int</span> sz)</span>;</span><br></pre></td></tr></table></figure><h3 id="C-C-调用-Lua"><a href="#C-C-调用-Lua" class="headerlink" title="C/C++调用 Lua"></a><strong>C/C++调用 Lua</strong></h3><p><strong>C/C++ 获取 Lua 值</strong></p><ol><li>使用 lua_getglobal 来获取值并将其压栈。</li><li>使用 lua_toXXX 将栈中元素取出（此时元素并不会出栈）转成相应的 C/C++ 类型的值。</li></ol><p><strong>C/C++ 调用 Lua 函数</strong></p><ol><li>使用 lua_getglobal 来获取函数并将其压栈。</li><li>如果这个函数有参数的话，就需要依次将函数的参数也压入栈。</li><li>调用 lua_pcall 开始调用函数，调用完成以后，会将返回值压入栈中。</li><li>取返回值，调用完毕。</li></ol><h3 id="Lua-调用-C-C"><a href="#Lua-调用-C-C" class="headerlink" title="Lua 调用 C/C++"></a><strong>Lua 调用 C/C++</strong></h3><p>Lua 可以调用 C/C++ 的函数，步骤为：</p><ol><li><code>将 C 的函数包装成 Lua 环境认可的函数</code>：将被调用的 C/C++ 函数从普通的 C/C++ 函数包装成 Lua_CFunction 格式，并需要在函数中将返回值压入栈中，并返回返回值个数;</li><li><code>将包装好的函数注册到 Lua 环境中</code>：使用宏<code>lua_register</code> 调用<code>lua_pushfunction(L,f)</code> 和<code>lua_setglobal(L,n)</code>，将函数存放在一个全局 table 中。</li><li>像使用普通 Lua 函数那样使用注册函数。</li></ol><p>PS：注意 XLua 或 ToLua 都是对 Lua 虚拟机做了上层封装，方便进行相关接口调用。</p><hr><h2 id="Lua-的闭包（主要通过-upValue-实现）"><a href="#Lua-的闭包（主要通过-upValue-实现）" class="headerlink" title="Lua 的闭包（主要通过 upValue 实现）"></a>Lua 的闭包（主要通过 upValue 实现）</h2><h3 id="Lua-的闭包定义与使用"><a href="#Lua-的闭包定义与使用" class="headerlink" title="Lua 的闭包定义与使用"></a>Lua 的闭包定义与使用</h3><p>闭包：**<em>能够读取其他函数内部变量的函数</em>**。</p><p>常见形式：通过调用含有一个内部函数加上该外部函数持有的外部局部变量（upvalue）的外部函数产生的一个函数实例。（外部函数+外部局部变量+内部函数（闭包函数））。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">local</span> i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>//尾调用</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    c1=test()</span><br><span class="line">    c2=test()<span class="comment">--c1,c2是建立在同一个函数，同一个局部变量的不同实例上面的两个不同的闭包</span></span><br><span class="line">             <span class="comment">--闭包中的upvalue各自独立，调用一次test（）就会产生一个新的闭包</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(c1()) <span class="comment">--&gt;1</span></span><br><span class="line">    <span class="built_in">print</span>(c1()) <span class="comment">--&gt;2//重复调用时每一个调用都会记住上一次调用后的值，就是说i=1了已经</span></span><br><span class="line">    <span class="built_in">print</span>(c2())    <span class="comment">--&gt;1//闭包不同所以upvalue不同</span></span><br><span class="line">    <span class="built_in">print</span>(c2()) <span class="comment">--&gt;2</span></span><br></pre></td></tr></table></figure><p>由上文输出结果可知：闭包中的外部局部变量在每个函数实例中各自独立，两个实例的调用结果不会相互干扰。同时实例中的外部局部变量会被保存。</p><p>PS：由于迭代器需要保存上一次调用的状态与下一次成功调用的状态，可以正好用闭包的机制实现。（迭代器只是一个生成器，本身不带有循环）以下是迭代器的实现。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">　 <span class="function"><span class="keyword">function</span> <span class="title">list_iter</span><span class="params">(t)</span></span></span><br><span class="line">            <span class="keyword">local</span> i=<span class="number">0</span></span><br><span class="line">            <span class="keyword">local</span> n=<span class="built_in">table</span>.<span class="built_in">getn</span>(t)</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">                i=i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i&lt;=n <span class="keyword">then</span> <span class="keyword">return</span> t[i] <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">--使用</span></span><br><span class="line">t=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">90</span>&#125;</span><br><span class="line">iter=list_iter(t)<span class="comment">--调用迭代器产生一个闭包</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">local</span> element=iter()</span><br><span class="line">    <span class="keyword">if</span> element==<span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">       <span class="built_in">print</span>(element)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--泛型for使用：</span></span><br><span class="line">t=&#123;<span class="number">10</span>,<span class="number">0</span>,<span class="number">29</span>&#125;</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> list_iter(t) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--这里的list_iter()工厂函数只会被调用一次产生一个闭包函数，后面的每一次迭代都是用该闭包函数，而不是工厂函数</span></span><br></pre></td></tr></table></figure><h3 id="Lua-闭包的底层实现"><a href="#Lua-闭包的底层实现" class="headerlink" title="Lua 闭包的底层实现"></a>Lua 闭包的底层实现</h3><p>在 Lua 语言运行期间，任何时候只要 Lua 执行一个 function…end 表达式， 它就会创建一个新的闭包。同时每个闭包会包含以下内容：</p><ul><li>一个对<code>函数原型proto</code>的引用</li><li>一个对<code>环境</code>的引用（环境其实是一个表，函数可在该表中索引全局变量）</li><li>一个数组，数组中每个元素都是一个对 <code>upvalue</code> 的引用，可通过该数组来存取外层的局部变量 （upvalue 是 proto 中的一个信息，见上文）</li></ul><p>闭包最主要的特点是能够获取其他函数内部变量。Lua 是通过<code>upvalue 的结构</code>来实现该功能的，对任何外层局部变量的存取都能间接地通过 upvalue 来进行。upvalue 最初指向栈中变量活跃的地方（图 4 左边） 。当离开变量作用域时（超过变量生存期时） ，变量被复制到 upvalue 中（图 4 右边） 。由于对变量的存取是通过 upvalue 里的指针间接进行的，因此复制动作对任何存取此变量的代码来说都是没有影响的。</p><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled5.png" alt="Untitled"></p><p>与内层函数不同的是， 声明该局部变量的函数直接在堆栈中存取它的局部变量。<code>通过为每个变量至少创建一个 upvalue 并按所需情况进行重复利用</code>，保证了未决状态（是否超过生存期）的局部变量（pending vars）能够在闭包间正确地共享。<code>为了保证这种唯一性， Lua 为整个运行栈保存了一个链接着所有正打开着的 upvalue（那些当前正指向栈内局部变量的 upvalue）的链表</code>（图 4 中未决状态的局部变量的链表） 。当 Lua 创建一个新的闭包时，它开始遍历所有的外层局部变量，对于其中的每一个，若在上述 upvalue 链表中找到它，就重用此 upvalue，否则， Lua 将创建一个新的 upvalue 并加入链表中。注意，<code>一般情况下这种遍历过程在探查了少数几个节点后就结束了</code>， 因为对于每个被内层函数用到的外层局部变量来说，该链表至少包含一个与其对应的入口（upvalue） 。一旦某个关闭的 upvalue 不再被任何闭包所引用，那么它的存储空间就立刻被回收。</p><p>一个函数有可能存取其更外层函数而非直接外层函数的局部变量。 这种情况下，有可能当闭包创建时，此局部变量尚不存在。 <code>Lua 使用 flat 闭包</code>来处理这种情况。<code>有了 flat 闭包，无论何时只要函数存取更外层的局部变量，该变量也会进入其直接外层函数的闭包中</code>。这样，当一个函数被实例化时，所有进入其闭包的变量就在直接外层函数的栈或闭包中了。</p><hr><h3 id="Lua-的元表与元方法（面向对象）"><a href="#Lua-的元表与元方法（面向对象）" class="headerlink" title="Lua 的元表与元方法（面向对象）"></a>Lua 的元表与元方法（面向对象）</h3><p>在 Lua table 中我们可以访问对应的 key 来得到 value 值，但是却无法对两个 table 进行操作。因此<code>Lua 提供了元表(Metatable)，允许我们改变table的行为，每个行为关联了对应的元方法</code>。通俗来说，元表就像是一个“操作指南”，里面包含了一系列操作的解决方案，例如<strong>index 方法就是定义了这个表在索引失败的情况下该怎么办，</strong>add 方法就是告诉 table 在相加的时候应该怎么做。这里面的<strong>index，</strong>add 就是元方法。（上文 table 表的结构中可以看见元表与元方法标记）</p><h3 id="面向对象的实现"><a href="#面向对象的实现" class="headerlink" title="面向对象的实现"></a>面向对象的实现</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--基类Account</span></span><br><span class="line">Account = &#123;balance = <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Account:new</span> <span class="params">(o)</span></span></span><br><span class="line">o = o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(o, <span class="built_in">self</span>)//设置元表为自身</span><br><span class="line"><span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span>//设置<span class="built_in">__index</span>元方法为自身</span><br><span class="line"><span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Account:deposit</span> <span class="params">(v)</span></span></span><br><span class="line"><span class="built_in">self</span>.balance = <span class="built_in">self</span>.balance + v</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Account:withdraw</span> <span class="params">(v)</span></span></span><br><span class="line"><span class="keyword">if</span> v &gt; <span class="built_in">self</span>.balance <span class="keyword">then</span> <span class="built_in">error</span><span class="string">&quot;insufficient funds&quot;</span> <span class="keyword">end</span></span><br><span class="line"><span class="built_in">self</span>.balance = <span class="built_in">self</span>.balance - v</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--子类SpecialAccount</span></span><br><span class="line"><span class="comment">--此时代表SpecialAccount是Account的一个实例，即继承了Account所有内容</span></span><br><span class="line">SpecialAccount = Account:new()</span><br><span class="line"></span><br><span class="line"><span class="comment">--SpecialAccount从Account继承了new方法</span></span><br><span class="line"><span class="comment">--new执行时，self指向SpecialAccount</span></span><br><span class="line"><span class="comment">--s的metable，__index是SpecialAccount</span></span><br><span class="line">s = SpecialAccount:new&#123;limit = <span class="number">1000.00</span>&#125;//s继承了SpecialAccount</span><br><span class="line"></span><br><span class="line"><span class="comment">--在s中找不到deposit域，会到SpecialAccount找，然后到Account中找</span></span><br><span class="line">s:deposit(<span class="number">100.00</span>)</span><br><span class="line"><span class="comment">--------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">--根据上面的描述，我们就可以在SpecialAccount中重写Account方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialAccount:withdraw</span> <span class="params">(v)</span></span></span><br><span class="line"><span class="keyword">if</span> v - <span class="built_in">self</span>.balance &gt;= <span class="built_in">self</span>:getLimit() <span class="keyword">then</span></span><br><span class="line"><span class="built_in">error</span><span class="string">&quot;insufficient funds&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">self</span>.balance = <span class="built_in">self</span>.balance - v</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialAccount:getLimit</span> <span class="params">()</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">self</span>.limit <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--调用方法 s:withdraw(200.00)，Lua 不会到 Account 中查找</span></span><br><span class="line"><span class="comment">--因为它第一次就在 SpecialAccount 中发现了新的 withdraw 方法</span></span><br><span class="line"><span class="comment">--由于 s.limit 等于 1000.00（记住我们创建 s 的时候初始化了这个值）</span></span><br><span class="line"><span class="comment">--程序执行了取款操作，s 的 balance 变成了负值</span></span><br><span class="line">s:withdraw(<span class="number">200.00</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="Lua-语言的-GC-算法"><a href="#Lua-语言的-GC-算法" class="headerlink" title="Lua 语言的 GC 算法"></a>Lua 语言的 GC 算法</h2><h3 id="两种常见的垃圾回收算法"><a href="#两种常见的垃圾回收算法" class="headerlink" title="两种常见的垃圾回收算法"></a>两种常见的垃圾回收算法</h3><ul><li><strong>自动引用计数(Automatic Reference Counting)算法</strong>（****ARC 算法****）<ul><li>对每一个对象保存一个整形的引用计数属性，用来记录对象被引用的情况，当记录对象被引用数维 0 时，将会被 GC 进行回收。</li><li>实现简单，判定效率高，回收没有延迟</li><li>单独的存储计数器字段，增加了存储空间的开销；每次赋值需要更新存储计数器增加了时间开销；<strong>无法处理循环引用问题</strong>（致命）</li><li>解决方法（Java）：可达性分析（不可达对象不等于无引用对象，最少要分析标记两次）<br><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled6.png" alt="Untitled"></li></ul></li><li>*<strong>*标记-清除（Mark - Sweep）算法**</strong><ul><li>当堆中的有效内存空间被耗尽时，停止整个程序，进行标记工作与清除工作<ul><li>标记：****Collector****从根节点开始遍历，标记所有被引用对象。（一般在对象的 Header 中记录为可达对象）</li><li>清除：****Collector****对堆内存进行从头到尾的线性遍历，发现没有标记为可达对象的对象将其回收</li></ul></li><li>效率低，GC 时需要停止整个用户进程，用户体验差，清理出的内存不连续没需要维护一个空闲链表</li></ul></li></ul><h3 id="Lua-的-GC-原理与算法设计"><a href="#Lua-的-GC-原理与算法设计" class="headerlink" title="Lua 的 GC 原理与算法设计"></a>Lua 的 GC 原理与算法设计</h3><ul><li>Lua 语言的 GC 算法采用<code>标记-清除（Mark - Sweep）算法</code></li><li>在 Lua5.1 之前，Lua 的 GC 过程是一次性不可打断的过程，采用的 Mark 算法是双色标记算法，黑色不被回收，白色被回收。但是如果在 GC 过程的回收阶段中，加入新的对象，不论标记成什么颜色都不对，所以在后来被改进</li><li>Lua5.1 之后采用了分布回收（增量 GC 的实现）以及<code>三色增量标记清除算法</code><br>更新之后的节点主要分为三种：<ul><li><strong>黑色节点</strong>：已经完全扫描过的节点。</li><li><strong>灰色节点</strong>：在扫描黑色节点时候初步扫描到，但是还未完全扫描的 obj，这类 obj 会被放到一个待处理列表中进行逐个完全扫描。</li><li><strong>白色节点</strong>：还未被任何黑色节点所引用的节点(因为一旦被黑色节点引用将被置为黑色或灰色)。这里白色又被进一步细分为<strong>cur white</strong>和<strong>old white</strong>，lua 会记录当前的<strong>cur white</strong>颜色，每个节点新创建的时候都是<strong>cur white</strong>，lua 会在 mark 阶段结束的时候翻转这个<strong>cur white</strong>的位，从而使得这之前创建的白色节点都是<strong>old</strong>的，在 sweep 阶段能够得到正确释放。</li></ul></li></ul><p>GC 的主要流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">为每一个新创建的节点设置为cur white（当前白色）</span><br><span class="line"><span class="comment">//初始化阶段</span></span><br><span class="line">遍历root根节点的引用对象，将white（所有白色）设置成灰色，放入灰色节点链表中</span><br><span class="line"><span class="comment">//标记阶段（存在引用屏障，保证黑色节点不指向白色节点，灰色是屏障）</span></span><br><span class="line">循环扫描灰色链表中的元素，将其置为黑色，然后扫描与该元素关联的其他元素，白色置灰加入灰色节点链表</span><br><span class="line">结束回收阶段，将所有cur white的节点设置成old white的节点（保证这些节点都是要被回收的，回收阶段新加入的白色节点不回收）</span><br><span class="line"><span class="comment">//回收阶段</span></span><br><span class="line">（可能存在新的白色节点加入，设置为cur white）</span><br><span class="line">遍历所有对象，回收所有old white节点</span><br></pre></td></tr></table></figure><hr><h2 id="Lua-语言的基础写法"><a href="#Lua-语言的基础写法" class="headerlink" title="Lua 语言的基础写法"></a>Lua 语言的基础写法</h2><p>指路：<a href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程 | 菜鸟教程 (runoob.com)</a></p><hr><h2 id="参考文献与学习资料"><a href="#参考文献与学习资料" class="headerlink" title="参考文献与学习资料"></a>参考文献与学习资料</h2><ul><li><a href="https://blog.csdn.net/yuanlin2008/article/details/8486463">探索 Lua5.2 内部实现:编译系统(1) 概述_yuanlin2008 的博客-CSDN 博客</a></li><li><a href="https://www.lfzxb.top/the-theory-of-lua-5-0/">Lua5.0 原理探究 | 登峰造极者，殊途亦同归。 (lfzxb.top)</a></li><li><a href="https://www.codingnow.com/2000/download/The%20Implementation%20of%20Lua5.0.pdf">The Implementation of Lua5.0.pdf (codingnow.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/454695276?utm_id=0">Lua 跨语言调用 - 知乎 (zhihu.com)</a></li><li>Brent 论文提到的 HashTable 增查新方法 地址：<a href="https://maths-people.anu.edu.au/~brent/pd/rpb013.pdf">https://maths-people.anu.edu.au/~brent/pd/rpb013.pdf</a></li><li><a href="https://www.cnblogs.com/Jaysonhome/category/1557006.html">Lua 相关 - 随笔分类 - 天山鸟 - 博客园 (cnblogs.com)</a></li><li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/v_xchen_v/article/details/77249332">https://link.zhihu.com/?target=https%3A//blog.csdn.net/v_xchen_v/article/details/77249332</a></li><li>《Lua 的设计与实现》</li><li>《Lua5.3 王桂林》</li></ul>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity渲染顺序探究</title>
      <link href="/2023/09/05/Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/"/>
      <url>/2023/09/05/Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间在群里看见一个有关于求问Unity渲染透明物体与不透明物体渲染顺序的问题，有群友提到了深度与渲染顺序有关，就去找了相关资料学习，并在这里记录一下。</p><h3 id="Unity的UGUI层级渲染顺序管理"><a href="#Unity的UGUI层级渲染顺序管理" class="headerlink" title="Unity的UGUI层级渲染顺序管理"></a>Unity的UGUI层级渲染顺序管理</h3><p><img src="../Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/Untitled.png" alt="Untitled"></p><p>摄像机的Depth：值越大，渲染物体越靠上，<strong>摄像机会根据Depth从小到大的顺序，渲染各自Culling Mask的层。</strong></p><p>RenderQueue：渲染物体的透明度，小于2500的先渲染</p><p>SortingLayer：SortingLayer在Inspector面板中点击Tag -&gt; AddTag -&gt; SortingLayer，可以添加自定义的sortingLayer，默认的sortingLayer为Default</p><p>Order In Layer：SortingLayer中的内部渲染排序。</p><p><img src="../Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/Untitled1.png" alt="Untitled"></p><p><img src="../Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/Untitled2.png" alt="Untitled"></p><p>RectTransform.SetSiblingIndex：设置显示与渲染顺序，值越大，越靠上</p><ul><li>SetAsFirstSibling：移动到所有兄弟节点的第一个位置（Hierarchy同级最上面，先渲染，显示在最下面）</li><li>SetAsLastSibling：移动到所有兄弟节点的最后一个位置（Hierarchy同级最下面，后渲染，显示在最上面）</li><li>GetSiblingIndex：获得该元素在当前兄弟节点层级的位置</li><li>SetSiblingIndex：设置该元素在当前兄弟节点层级的位置</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 图形渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A*算法</title>
      <link href="/2023/08/06/A-%E7%AE%97%E6%B3%95/"/>
      <url>/2023/08/06/A-%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一种在静态路网中求解最短路径最有效的直接搜索算法。</p><hr><h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><p>F=G+H（f*(n)=g*(n)+h*(n)）</p><p>G：代表从起点A移动到指定方格的移动代价（路径长短）</p><p>H：代表从指定方格移动到终点B的移动代价（路径长短）</p><hr><h3 id="G点的计算"><a href="#G点的计算" class="headerlink" title="G点的计算"></a>G点的计算</h3><p>PS：需要使用到开放列表中父节点的应用</p><ul><li>假设角色横向与纵向的移动代价是10，对角线的移动代价是14（平方根）,。计算G值的方法就是找到父节点的G值，再根据横纵向，还是对角线为G值加上10或14。</li></ul><h3 id="H值的估算-Manhattan-方法：试探法"><a href="#H值的估算-Manhattan-方法：试探法" class="headerlink" title="H值的估算(Manhattan 方法：试探法)"></a>H值的估算(Manhattan 方法：试探法)</h3><p>PS：方法有很多不同的，可上网查找。</p><ul><li>计算从当前方格横向或纵向移动到达目标所经过的方格数，忽略对角移动，然后把总数乘以 10。</li></ul><h3 id="openlist（开放列表）与closelist（封闭列表）"><a href="#openlist（开放列表）与closelist（封闭列表）" class="headerlink" title="openlist（开放列表）与closelist（封闭列表）"></a>openlist（开放列表）与closelist（封闭列表）</h3><ul><li>openlist：记录所有被考虑来寻找最短路径的网格集合（经过路径的所有相邻节点逐渐加入该列表）</li><li>closelist：一个记录下不会被考虑的网格集合（已经被选中的路径点加入该列表）</li></ul><hr><p><img src="../A-%E7%AE%97%E6%B3%95/Untitled.png" alt="Untitled"></p><h3 id="寻路步骤："><a href="#寻路步骤：" class="headerlink" title="寻路步骤："></a>寻路步骤：</h3><ul><li>简化搜索区域，将搜索区域简化成2维数组，数组中每一项代表一个格子。状态分成可走与不可走。</li><li>从起点A开始，将其加入方格组成的openlist（开放列表）中，列表中的格子是路径可能会沿途经过的（有可能经过的方块格）。  <img src="../A-%E7%AE%97%E6%B3%95/Untitled1.png" alt="Untitled"></li><li>查找与A相邻的方格（忽略障碍物所在的格子），将所有可达的方格加入到openlist列表当中，并且将起点A设置成这些可达方格的父节点。</li><li>将方格A从openlist列表中移除，加入到closelist（封闭列表）当中。</li><li>根据公式计算，取出openlist表中F值最小的方格数据，放入closelist中。</li><li>检索该方格相邻的所有方格，忽略不可达以及在closelist中的方格，openlist中，并为加入的方格设置父节点。重复以上操作。</li><li>如果发现相邻的方格已经存在了openlist当中，就检查这条路径是否更优（是否具有更小的G值），没有则不作操作。如果 G 值更小，则把那个方格的父亲设为当前方格 ( 我们选中的方格 )，然后重新计算那个方格的 F 值和 G 值</li></ul><hr><h3 id="算法性能的提高"><a href="#算法性能的提高" class="headerlink" title="算法性能的提高"></a>算法性能的提高</h3><ul><li>可以再openlist表中保存好路径元素，并且对表中元素进行排序，这样每次取值只要取第一个方格的数据就行</li><li>使用二叉堆（快2~3倍）：<a href="http://www.policyalmanac.org/games/binaryHeaps.htm">Using Binary Heaps in A* Pathfinding</a></li><li>系列点子<ul><li>使用小地图或者更少的寻路者</li><li>千万不要同时给多个寻路者寻路。取而代之的是把它们放入队列中，分散到几个游戏周期中。</li><li>考虑在地图中使用更大的方格。这减少了寻路时需要搜索的方格数量。或长路径使用大方块，接近目标使用小方块。资料：<a href="http://www.policyalmanac.org/games/twoTiered.htm">Two-Tiered A* Pathfinding</a></li><li>对于很长的路径，考虑使用路径点系统，或者可以预先计算路径并加入游戏中。</li><li>预先处理你的地图，指出哪些区域是不可到达的。这些区域称为“孤岛”。A* 的下限是，你告诉他搜寻通往哪些区域的路径时，他会搜索整个地图，直到所有可以抵达的方格都通过 open list 或 close list 得到了处理。</li><li>不同的地形损耗，地形不是只有 2 种：可抵达的和不可抵达，不同的地形移动代价可以不同，沼泽，山丘，地牢的楼梯等等</li><li>influence Mapping：创建一个额外的计分系统，把它应用到寻路的 AI 中。地图上有个通道穿过山丘，有大批的寻路者要通过这个通道，电脑每次产生一个通过那个方格的路径都会变得很拥挤。如果需要，你可以产生一个 influence map，用来标记提高那些方格的移动代价，让电脑避开那个区域移动</li><li>采用布兰森汉姆算法预先判断两点是否可以直接通行,可通行就直接返回两点的直线路径,不可直接通行再采用A星算法寻路</li><li>A*算法走的是最小代价路径，但不一定是最平滑的路径。可以增加一个额外开销，作为允许G值的一定波动范围，然后查找相邻格子中最平滑的地方。</li></ul><hr>  github简单实例链接（没做优化版）：<a href="https://github.com/The-Black-Sun/Static_pathfinding_algorithm_A_Star">https://github.com/The-Black-Sun/Static_pathfinding_algorithm_A_Star</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 路径规划，性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
