<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>UnityShader学习总结：基础初级篇</title>
      <link href="/2023/10/07/UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/"/>
      <url>/2023/10/07/UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上个月读了《Unity Shader 入门精要》这本书，原本准备将学习笔记整理一下，作为博文发布出来，复习的时候检查了一下。发现很大程度上与书籍内容相同，有点抄书的嫌疑，想了想还是决定整理归纳一下，顺便查缺补漏，看看有没有被遗落的知识点，内容极其主观，特此声明。</p><hr><h1 id="基础部分：渲染流水线与Unity-Sahder基础"><a href="#基础部分：渲染流水线与Unity-Sahder基础" class="headerlink" title="基础部分：渲染流水线与Unity Sahder基础"></a>基础部分：渲染流水线与Unity Sahder基础</h1><p>这本书的基础部分主要是由渲染流水线的介绍和Unity Shader的基础写法构成的。这部分内容主要分布在全书的第2章与第3章。第一章主要介绍了一下全书内容结构，并没有涉及到太多的知识点。第4章主要介绍一些涉及图形学相关的数学知识，关于这部分内容，想要深入学习的同学可以去阅读一下相关书籍《3D游戏数学》。这本书详细介绍了3d游戏中，涉及图形学的数学概念，各个空间变换所需要的矩阵计算方法的底层原理等等。</p><h2 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h2><p>由于在大学期间学习过龙书（<strong><strong>DirectX12 3D游戏开发实战</strong></strong>），还跟着老师写过论文（混），所以对渲染流水线还是有着基本上的认识的，虽然DirectX12的渲染流水线与Unity的渲染存在一定程度上的差别，但是基础原理与专有名词还是相同的，对理解起来不会存在太大的难度。</p><p>在unity的渲染流水线中主要分为以下3个阶段：</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled.png" alt="Untitled"></p><p>分别是应用阶段，几何阶段以及光栅化阶段。其中应用阶段主要由CPU进行控制的，而几何阶段以及光栅化阶段则主要由GPU进行控制。</p><p><code>应用阶段</code>是CPU的工作阶段，由上图可以看出主要是负责将渲染图元（几何信息，顶点数据）提交给GPU并请求渲染。具体的工作这是：</p><ul><li>准备好场景数据（摄像机位置、模型、光源等等），进行粗粒度剔除的工作（根据视锥体剔除不可见物体），将不可见物体CPU首先需要将所需要的数据加载进显存当中（大多数显卡缺少对内存的访问权限）；</li><li>设置好渲染状态（告诉GPU这个渲染物体使用的材质，纹理，shader等等），会得到一个待渲染的几何信息，也就是<code>渲染图元</code>，在待渲染的图元列表中；</li><li>向GPU发送请求渲染命令，指向一个待渲染的图元列表，通知GPU进行渲染。</li></ul><p>这一部分的大部分工作能够在Unity的图形化界面上进行操作，包括但不限于：调整场景中物体（顶点，法线）位置，设置纹理（颜色、透明度调整）等等⇒部分纹理属性需要再在shader中定义对应属性。除此之外还有一部分需要再unity的Shader文件中进行设置，例如渲染状态等等。而CPU每次提交渲染图元，向GPU发出的一个请求渲染的命令就是通常开发者们熟悉的<code>DrawCall</code>。而通常对DrawCall的优化就是需要减少CPU发出的渲染命令，也就是减少图元列表，这通常也就需要使用到我们常说的<code>合批</code>与<code>图集</code>了，这里先不进行表述。</p><p><code>几何阶段</code>与<code>光栅化阶段</code>也就是我们需要重点关注的部分。内部可以细分成多个阶段，如下表所示：</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled1.png" alt="Untitled"></p><p><code>几何阶段</code>主要包括以下几个步骤：</p><p>顶点着色器：完全可编程。以单个顶点为单位进行处理，主要完成顶点坐标变换，逐顶点光照，计算顶点颜色等功能。</p><p>曲面细分着色器：完全可编程，可选。主要用来设置与生成高精度网格（细分图元）。</p><p>几何着色器：完全可编程，可选。进行逐图元的着色操作，或者产生更多的图元。</p><p>剪裁：可配置。（注意与CPU的粗粒度剔除的区别）将摄像机视锥体范围外的<code>物体部分</code>剔除（产生新顶点替代边界）。</p><p>屏幕映射：不可配置，不可编程。将图元坐标由齐次剪裁空间转化到屏幕坐标系中。</p><p><code>光栅化阶段</code>主要包括以下几个步骤：</p><p>三角形设置：不可配置，不可编程。根据几何阶段输出的顶点信息，获取三角形每条边的像素坐标，得到三角形边界的表达方式。</p><p>三角形遍历：不可配置，不可编程。检查像素点是否被三角网格覆盖，并生成片元（包括屏幕坐标，深度，发现，纹理等信息）。</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled2.png" alt="Untitled"></p><p>片元着色器：完全可编程。进行纹理采样，实现逐片元的着色操作。</p><p>逐片元操作：高度可配置。进行颜色修改，可见性测试（深度检测，模板检测），混合等操作。</p><ul><li>模板检测：将片元模板缓冲区的模板值与设置的参考值比较，比较函数由开发者指定，判断是否通过模板测试。</li><li>深度检测：将片元深度缓冲区的深度值与片元的深度值比较，比较函数由开发者指定，判断是否通过深度测试。如果通过深度测试，才有覆盖深度缓冲区值的权利，开发者可以选择是否覆盖（开启/关闭深度写入）</li><li>等等等等</li></ul><p>由上面介绍，可以看见有关于于<code>完全可编程</code>，<code>可配置</code>等等的字样。这些说明了开发者能够控制内部实现又或是能够配置对应阶段的相关属性，并且这些都是需要再Unity Shader文件中通过代码进行实现。在书中，后面章节主要通过使用了顶点着色器与片元着色器以及部分配置功能来实现效果，至于曲面细分着色器与几何着色器的使用，有兴趣的可以参考官网内容进行学习。</p><p>UnityShader文件主要通过类CG语言进行编写，由以上介绍可知，我们能够在顶点着色器，曲面细分着色器，几何着色器以及片元着色器中进行具体的效果实现，同时可以配置剪裁或逐片元操作的混合、深度写入等功能。</p><p>书中该部分内容还介绍了两大图形接口（OpenGL与DirectX），三大着色语言（HLSL、GLSL、CG）DrawCall，以及固定渲染管线的相关知识，与具体实现Shader相关效果联系不大，这里不做过多的介绍。</p><h2 id="Unity-Shader基础"><a href="#Unity-Shader基础" class="headerlink" title="Unity Shader基础"></a>Unity Shader基础</h2><p>该部分内容主要是书中第3章部分内容，主要介绍了UnityShader的整体结构。需要注意的是Shader是和材质相互绑定的，Unity中创建材质会自动绑定默认Shader，可以通过Unity界面上进行调整。</p><p>常见的UnityShader使用流程：</p><ul><li>创建一个材质</li><li>创建一个unity shader，并赋给材质</li><li>将材质赋给要渲染的对象</li><li>在材质面板调整Unity Shader中的属性</li></ul><p>需要注意的是，还存在其他情况的Shader使用情况，例如涉及到屏幕截取以及后处理等功能时（第12章），会通过代码创建材质并将相应Shader进行材质设置，不遵照上述使用流程。</p><p>除此之外，创建UnityShader文件还需要注意以下几种Unity的内置模板：</p><ul><li>Standard Surface Shader：一个包含标准光照模型的表面着色器模板。</li><li>Unlit Shader：一个不包含光效，但是包含雾效的基本的顶点/片元着色器</li><li>Image Effect Shader：一个用来处理各种屏幕后处理效果的模板</li><li>Compute Shader（例外）：利用GPU并行性进行一些与流水线无关计算的模板（白嫖计算量）</li><li>Ray Tracing Shader：一个光线追踪shader</li></ul><p>以下是2个常用Shader着色器的特点：</p><ul><li>表面着色器：代码量少，渲染代价大（unity实现的时候需要转换成顶点/片元着色器，相当于上层），unity内部自动处理光照细节<ul><li>不需要写Pass，最表层接口不关心（只实现什么纹理填充什么颜色，法线，使用什么光照模型等，进行表面渲染）</li><li>代码定义在CGPROGRAM与ENDCG之间</li><li>使用CG/HLSL语法</li><li>与光源打交道可以优先使用</li></ul></li><li>顶点/片元着色器：更加复杂，灵活性高<ul><li>代码定义在CGPROGRAM与ENDCG之间</li><li>需要写在Pass语义块中，需要自定义每个Pass使用的shader代码</li><li>使用CG/HLSL语法</li><li>需要许多自定义的渲染效果</li><li>和较少的光源打交道</li></ul></li></ul><p>在之后的学习的过程中主要采用创建使用了Unlit Shader模版（通过编写顶点/片元着色器实现具体特效效果，包括下列代码实例也是）。还有可能使用的Shader面板的相关设置：</p><ul><li>Default Maps：shader使用的默认纹理</li><li>Show generated code：unity为shader模板（我们创建的）生成的顶点/片元着色器代码。</li><li>Compile and show code（下拉列表）：直接点击查看底层汇编指令。下拉列表查看不同图形接口生成编译的shader代码。</li><li>其余信息：渲染队列（Render queue）情况，批处理（Disable batching）情况、属性列表等</li></ul><p>接下来就是Unity Shader代码文件的大概结构了：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shader名称，在跨Shader文件使用的时候会用到</span></span><br><span class="line">Shader &quot;ShaderName&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//属性，定义纹理，颜色，透明度等纹理相关属性，</span></span><br><span class="line"><span class="comment">//会在Unity材质面板上进行显示，根据设置能够调整对应参数</span></span><br><span class="line"><span class="comment">//名字|显示的名称|类型|赋值</span></span><br><span class="line">        <span class="comment">//_Color (&quot;Color&quot;, Color) = (1,1,1,1)</span></span><br><span class="line">        <span class="comment">//_MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显卡A使用的子着色器（顶点/片元），在内部定义</span></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//可选标签，控制整个SubShader</span></span><br><span class="line"><span class="comment">//设置渲染对列，渲染类型</span></span><br><span class="line"><span class="comment">//[Tags]</span></span><br><span class="line"><span class="comment">//Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可选状态，控制整个SubShader</span></span><br><span class="line"><span class="comment">//设置剔除模式，深度测试函数时，深度写入开关，以及混合模式</span></span><br><span class="line"><span class="comment">//[RenderSetup]</span></span><br><span class="line"><span class="comment">//Cull Back</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构,Pass可以定义多个</span></span><br><span class="line">Pass&#123;</span><br><span class="line">[Name]</span><br><span class="line">[Tags]</span><br><span class="line">[RenderSetup]</span><br><span class="line"><span class="comment">//Other code </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际写法</span></span><br><span class="line">Pass&#123;</span><br><span class="line"><span class="comment">//名称，ShaderLab可以使用UsePass命令来使用其他shader的pass。</span></span><br><span class="line"><span class="comment">//跨Shader文件调用时会用到</span></span><br><span class="line">Name &quot;MyPassName&quot;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UsePass使用方法，使用其他shader的pass。</span></span><br><span class="line">UsePass &quot;MyShader/MYPASSNAME&quot;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GrabPass使用方法，用来抓取屏幕并存储成一张纹理，用于后续的Pass处理。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//标签,这里的标签与Subshader不同，是用来设置怎么渲染的</span></span><br><span class="line">Tags &#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line"><span class="comment">//定义pass在渲染流水线中的角色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//状态，除了SubShader的状态之外，还有设置固定管线的着色器命令（3.4.3）</span></span><br><span class="line"><span class="comment">//关闭深度写入</span></span><br><span class="line"><span class="comment">//ZWrite Off</span></span><br><span class="line"><span class="comment">//设置透明混合命令</span></span><br><span class="line"><span class="comment">//Blend SrcAlpha OneMinusSrcAlpha</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//CG代码片段声明</span></span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="comment">//定义顶点着色器与片元着色器</span></span><br><span class="line"><span class="comment">//#pragma vertex vert</span></span><br><span class="line"><span class="comment">//#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用unityShader内置文件，包含变量与函数</span></span><br><span class="line"><span class="comment">//#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性值获取，之前定义的属性信息存储的位置</span></span><br><span class="line"><span class="comment">//fixed4 _Color;</span></span><br><span class="line"><span class="comment">//sampler2D _MainTex;</span></span><br><span class="line"><span class="comment">//float4 _MainTex_ST;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入顶点着色器结构体，根据具体需要声明，顶点，法线，纹理等信息</span></span><br><span class="line">struct a2v &#123;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//顶点着色器输出结构体，也是片元着色器输入结构体，神明世界空间顶点位置，法线，纹理</span></span><br><span class="line"><span class="comment">//甚至切线空间与世界空间的变换矩阵等</span></span><br><span class="line">struct v2f &#123;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line">v2f o;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//返回最后的合成颜色</span></span><br><span class="line"><span class="comment">//return ...;</span></span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显卡B</span></span><br><span class="line">SubShader</span><br><span class="line">    &#123;</span><br><span class="line">....</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//FallBack &quot;Diffuse&quot;</span></span><br><span class="line"><span class="comment">//回调Shader，当上述Shader不运行时使用定义Shader，可填Off</span></span><br><span class="line">FallBack &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是Properties语义块支持的属性类型：</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled3.png" alt="Untitled"></p><p>以下是SubShader标签中的标签类型：</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled4.png" alt="Untitled"></p><p>以下是SubShader状态的可设置类型：</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled5.png" alt="Untitled"></p><p>以下是Pass中的标签可设置类型：</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled6.png" alt="Untitled"></p><p>Pass的状态可设置类型与SubShader相同+固定渲染管线命令</p><hr><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul><li>GLSL使用文档：<a href="http://docs.unity3d.com/Manual/SL-GLSLShaderPrograms.html">http://docs.unity3d.com/Manual/SL-GLSLShaderPrograms.html</a></li><li>CG语言编写教程：<a href="https://developer.download.nvidia.cn/CgTutorial/cg_tutorial_chapter01.html">CG 教程 - 第 1 章。介绍 (nvidia.cn)</a></li></ul><hr><h1 id="初级部分：基础光照与基础纹理"><a href="#初级部分：基础光照与基础纹理" class="headerlink" title="初级部分：基础光照与基础纹理"></a>初级部分：基础光照与基础纹理</h1><p>了解了有关于Unity的渲染流程以及UnityShader的基本结构，那么接下来就是实际操作了，接下来的初级篇分别是第6张介绍了光照的基本原理，第7章介绍了基础的纹理效果实现，以及第8张讲述了透明效果的实现。</p><h2 id="基础光照"><a href="#基础光照" class="headerlink" title="基础光照"></a>基础光照</h2><p>对于了解图形学光照原理的同学，这一部分很好理解的。基础光照本身是由四个部分构成，分别是以下四个部分：</p><ul><li>自发光：<code>missive</code>，一个表面本身该向四周发射多少辐射量。如果没有使用全局光照技术，自发光的表面不会照亮周围物体，只是本身会显得更亮。直接使用材质的自发光颜色数据。</li><li>高光反射：<code>specular</code>，描述光线从光源照射到模型表面，该表面会以完全镜面反射散射多少辐射量。</li><li>漫反射：<code>diffuse</code>，描述光线从光源照射到模型表面，该表面会向每个方向散射多少辐射量。根据<code>兰伯特定律</code>：反射光线的强度与表面法线和光源方向之间的夹角的余弦值成正比。</li><li>环境光：<code>ambient</code>，用来描述其他所有的间接光照。使用一个全局变量来进行模拟。</li></ul><p>需要注意的，环境光与自发光都能够分别由场景中的平行光数据以及材质的数据直接获取。所以要完成基本光照在于实现漫反射与高光反射。</p><h3 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h3><p>首先是漫反射的原理主要根据兰伯特定律进行实现，是根据材质本身的颜色以及光源颜色向四周反射光线，以下是光照的计算公式，也是<code>兰伯特模型</code>：</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled7.png" alt="Untitled"></p><p>其中n是表面法线；I是指向光源的单位矢量，Mdiffuse是材质的漫反射颜色，Clight是光源颜色。0和点乘结果取最大值，避免物体被从后方来的光源照亮。</p><p>除了上述的兰伯特模型之外，还有一个半兰伯特模型也用来实现漫反射效果，这是因为兰伯特模型在处理模型背光的情况下会发现模型全黑的情况（模型细节完全丢失，看过去全是黑的，没有轮廓），这是因为在上述计算中法线与光源的余弦值如果是负数，就会统一变成0来限制背光被照亮的情况。但是也导致了背光没有漫反射效果。</p><p>为了解决这个问题，就采用了<code>半兰伯特模型</code>来进行改进。对于法线与入射光线的余弦值的max处理修正为进行一个a倍的缩放以及一个b大小的偏移。通常情况下是0.5。这样映射范围就在[0,1]之间。</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled8.png" alt="Untitled"></p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled9.png" alt="Untitled"></p><p>接下来就主要是根据UnityShader的实际结构实现漫反射光照了，这里加上一个完整的Shader文件进行展示，之后如果有同样的代码内容只展示原理实现部分：</p><ul><li>漫反射效果=入射光线<em>漫反射系数</em>法线与入射光线的余弦值（具体公式上查）</li><li>Max函数的写法⇒函数saturate(x)，参数x是用于操作的标量或矢量，是float、float2、float3类型。能够将x截取在[0,1]范围内，如果x是矢量，就对每一个分量都进行一次该操作。</li></ul><p>以下是基于顶点着色器实现的兰伯特漫反射光照：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Diffuse Vertex-Level&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        <span class="comment">//漫反射颜色</span></span><br><span class="line">        _Diffuse(&quot;Diffuse&quot;,color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">       Pass&#123;</span><br><span class="line">            Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明顶点着色器与片元着色器</span></span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include&quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义输出输入结构体</span></span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex:POSITION;</span><br><span class="line">                float3 normal:NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos:SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//顶点从模型空间转换到剪裁空间中；UNITY_MATRIX_MVP=&gt;模型*世界*投影矩阵</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//获取环境光，UNITY_LIGHTMODEL_AMBIENT</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//在世界空间计算，mul，点乘，将模型顶点的法线与世界矩阵相乘，获取世界空间的顶点法线；</span></span><br><span class="line">                <span class="comment">//_World2Object 模型空间到世界空间的变换矩阵的逆矩阵，调换在mul中的位置，得到与转置矩阵相同的矩阵乘法</span></span><br><span class="line">                <span class="comment">//normalize 归一化</span></span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获得环境光的光源方向</span></span><br><span class="line">                fixed3 worldLight = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//漫反射=环境光*表面漫反射颜色*世界法线与世界入射光夹角的余弦值（小于0，则取0）</span></span><br><span class="line">                <span class="comment">//saturate 截取[0,1]</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldNormal, worldLight));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//光照效果=环境光+漫反射</span></span><br><span class="line">                o.color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) :SV_Target&#123;</span><br><span class="line">                <span class="keyword">return</span> fixed4(i.color,<span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上述代码可以看出，兰伯特光照的计算填写在顶点着色器中，也就是说这里实现的是逐顶点光照。但如果使用片元着色器的话能够得到更好的效果。原因在于模型的细分程度，如果是顶点数量高的高细分模型，逐渐顶点关照能够表现出良好的效果，如果是低细分模型可能会存在一些视觉问题（锯齿等）。</p><p>以下是逐像素兰伯特漫反射的实现：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="comment">//可以使用unity的内置函数</span></span><br><span class="line"><span class="comment">//负责将过顶点位置转换到投影空间</span></span><br><span class="line"><span class="comment">//将顶点法线从模型空间转换到世界空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//片元着色器（漫反射原理实现）</span></span><br><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line"><span class="comment">//进行漫反射数据计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取环境光数据</span></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取世界空间的顶点法线，并归一化</span></span><br><span class="line">fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取世界空间的光源归一化矢量</span></span><br><span class="line">fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行漫反射模型计算</span></span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并环境光与漫反射光线</span></span><br><span class="line">fixed3 color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了兰伯特模型之外，这里也能够进行半兰伯特效果的实现：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line"><span class="comment">//获取环境光数据</span></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取世界空间的顶点法线，并归一化</span></span><br><span class="line">fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取世界空间的光源归一化矢量</span></span><br><span class="line">fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行漫反射模型计算</span></span><br><span class="line">fixed halfLambert = <span class="built_in">dot</span>(worldNormal, worldLightDir) * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * halfLambert;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并环境光与漫反射光线</span></span><br><span class="line">fixed3 color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高光反射"><a href="#高光反射" class="headerlink" title="高光反射"></a>高光反射</h3><p>高光反射主要根据两个高光反射模型进行实现的，分别是Phone高光反射模型与Bline高光反射模型。Phone模型主要根据光源的<code>反射光线与视角方向之间的夹角</code>来确定颜色显示。而Bline高光反射模型主要是引入新的矢量h作为入射光线与视角方向的一个划分平均值，并通过他<code>与法线方向之间的夹角</code>确定颜色。如下：</p><ul><li><strong>Phone高光反射模型：</strong>  <img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled10.png" alt="Untitled"><ul><li>反射方向计算方法  <img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled11.png" alt="Untitled"></li><li>高光反射计算方法  <img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled12.png" alt="Untitled"><ul><li>Mglass是表面的光泽度，Mspecular是表面的高光反射颜色，控制高光反射的强度与颜色，Clight是光源的颜色与强度</li></ul></li></ul></li><li><strong>Bline高光反射模型</strong>  引入新的矢量h，作为入射光线l与出射光线v的一个平均值（使用时需要进行归一化变成单位矢量）  <img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled13.png" alt="Untitled"><ul><li>计算中间平均矢量的单位矢量  <img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled14.png" alt="Untitled"></li><li>高光反射计算方法  <img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled15.png" alt="Untitled"><ul><li>Mglass是表面的光泽度，Mspecular是表面的高光反射颜色，控制高光反射的强度与颜色，Clight是光源的颜色与强度</li></ul></li></ul></li></ul><p>总而言之，<strong>高光反射效果</strong>=<strong>入射光线</strong><em><strong>高光反射系数</strong></em>（<strong>视角方向</strong>与<strong>反射方向</strong>的<strong>余弦值</strong>）或（<strong>视角方向</strong>与平分矢量的<strong>余弦值</strong>）的<strong>物体表面光泽度的指数方</strong>（具体公式上查）</p><p>以下是Phone高光反射的逐顶点光照实现：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line">v2f o;</span><br><span class="line"><span class="comment">//顶点：模型空间=&gt;投影空间</span></span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//环境光</span></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法线：模型空间=&gt;世界空间</span></span><br><span class="line">fixed3 worldNormal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line"><span class="comment">//入射方向，归一化</span></span><br><span class="line">fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line"><span class="comment">//漫反射</span></span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射光线，归一化</span></span><br><span class="line">fixed3 reflectDir = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-worldLightDir, worldNormal));</span><br><span class="line"><span class="comment">//视角方向，归一化</span></span><br><span class="line">fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld, v.vertex).xyz);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取高光反射效果</span></span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(saturate(<span class="built_in">dot</span>(reflectDir, viewDir)), _Gloss);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终效果=环境光+漫反射+高光反射</span></span><br><span class="line">o.color = ambient + diffuse + specular;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是Phone高光反射的逐像素光照实现：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line"><span class="comment">//环境光</span></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line"><span class="comment">//世界法线</span></span><br><span class="line">fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line"><span class="comment">//世界，入射光线（反向的）</span></span><br><span class="line">fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line"><span class="comment">//漫反射效果</span></span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射光线归一化</span></span><br><span class="line">fixed3 reflectDir = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-worldLightDir, worldNormal));</span><br><span class="line"><span class="comment">//世界空间，观察视角（摄像机-顶点位置）</span></span><br><span class="line">fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line"><span class="comment">//高光反射</span></span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(saturate(<span class="built_in">dot</span>(reflectDir, viewDir)), _Gloss);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是blinn-Phone模型高光反射的逐像素光照实现：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line"><span class="comment">//环境光</span></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line"><span class="comment">//世界法线</span></span><br><span class="line">fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line"><span class="comment">//世界，入射光线（反向的）</span></span><br><span class="line">fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line"><span class="comment">//漫反射效果</span></span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line"><span class="comment">//世界空间，观察视角</span></span><br><span class="line">fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line"><span class="comment">//反射夹角中线，归一化</span></span><br><span class="line">fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line"><span class="comment">//高光反射效果</span></span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是光照效果图：</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled16.png" alt="Untitled"></p><h3 id="Unity常用内置函数"><a href="#Unity常用内置函数" class="headerlink" title="Unity常用内置函数"></a>Unity常用内置函数</h3><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled17.png" alt="Untitled"></p><hr><h2 id="基础纹理"><a href="#基础纹理" class="headerlink" title="基础纹理"></a>基础纹理</h2><p>Unity Shader的使用离不开纹理，所以第7章内容介绍了在unityShader中的纹理使用，分别介绍了单张纹理的使用，凹凸映射（法线）纹理的使用，渐变纹理的使用以及遮罩纹理的使用。</p><h3 id="单张纹理的使用"><a href="#单张纹理的使用" class="headerlink" title="单张纹理的使用"></a>单张纹理的使用</h3><p>首先是单张基础纹理的使用，首先需要定义Shader中纹理的属性，之后在Pass中声明属性存储之前定义的属性信息，设置好进出着色器的存储信息的结构体，之后再在顶点着色器中进行纹理采样即可。</p><p>重点在于顶点着色器中对纹理的偏移以及在片元着色器中对纹理的采样，可以使用unity内置的偏移函数<strong>TRANSFORM_TEX（纹理，偏移量）</strong>以及采样函数**tex2D(纹理,偏移UV)**。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Single Texture&quot;&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//定义纹理和会用到的纹理属性</span></span><br><span class="line">        <span class="comment">//颜色</span></span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="comment">//声明一个2D纹理，内置纹理“white”，全白</span></span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">//镜面反射（高光反射）</span></span><br><span class="line">        _Specular(&quot;Specular&quot;,Color)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="comment">//光泽（材质高光反射光泽度，计算后面的那个指数）</span></span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>,<span class="number">256</span>)) =<span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">       Pass&#123;</span><br><span class="line">            <span class="comment">//光照模式</span></span><br><span class="line">            Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma frafment frag</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Properties中的属性描述</span></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//纹理属性描述，st是缩放和平移的缩写，.xy存放的是缩放值，.zw存放的是偏移值</span></span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//输出输入结构体</span></span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex:POSITION;</span><br><span class="line">                float3 normal:NORMAL;</span><br><span class="line">                <span class="comment">//模型第一组纹理坐标</span></span><br><span class="line">                float4 texcoord:TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos:SV_POSITION;</span><br><span class="line">                float3 worldNormal:TEXCOORD0;</span><br><span class="line">                float3 worldPos:TEXCOORD1;</span><br><span class="line">                <span class="comment">//存储纹理采样数据，对纹理坐标进行采样</span></span><br><span class="line">                float2 uv:TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">       </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line"></span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//_MainTex_ST.xy 与纹理坐标相乘，进行缩放，加上_MainTex_ST.zw进行纹理偏移</span></span><br><span class="line">                o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                <span class="comment">//以上过程可以直接调用TRANSFORM_TEX函数</span></span><br><span class="line">                <span class="comment">// TRANSFORM_TEX(tex,name)</span></span><br><span class="line">                <span class="comment">// tex=&gt;顶点纹理坐标，name=&gt;纹理名称</span></span><br><span class="line">                <span class="comment">//o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//输出</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//使用纹理对漫反射颜色进行采样</span></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//漫反射</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Bline模型</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上述在UnityShader脚本中编写的代码之外，材质需要绑定Shader，根据Shader中的属性设置能够绑定纹理，但同时还需要注意一下纹理的界面设置：</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled18.png" alt="Untitled"></p><ul><li>Texture Type：纹理类型</li><li>Alpha Source：透明度选项来源（from Grayscale  来自像素灰度值生成，等等）</li><li>Wrap Mode：贴图模式<ul><li>Repeat：纹理坐标超过1，整数部分舍弃，直接使用小数部分进行采样（纹理将会不断重复）</li><li>Clamp：纹理坐标大于1，将会截取到1，如果小于0，将会截取到0（超出范围部分取纹理边界颜色）  <img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled19.png" alt="Untitled"></li></ul></li><li>Filter Mode：滤波模式，一共有三种：Point，Bilinear，Trilinear。得到的图片显示效果依次提升。以下是三种效果：<ul><li>Point：采样像素点数目只有一个</li><li>Bilinear：采用了线性滤波，每个像素目标会找周围4个邻近像素，通过线性插值混合之后最终像素。</li><li>Trilinear：大致与Bilinear相同，只是多了<strong>多级渐远纹理</strong>之间的相互混合。</li></ul></li></ul><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled20.png" alt="Untitled"></p><h3 id="多级渐远纹理（mipmapping）技术（有点像lod技术，⇒Levels-of-Detail）"><a href="#多级渐远纹理（mipmapping）技术（有点像lod技术，⇒Levels-of-Detail）" class="headerlink" title="多级渐远纹理（mipmapping）技术（有点像lod技术，⇒Levels of Detail）"></a>多级渐远纹理（mipmapping）技术（有点像lod技术，⇒Levels of Detail）</h3><p>将原纹理提前使用滤波处理得到更小的图像，形成图像金字塔，每一层级都是上一层级的降采样效果。（需要多余空降进行降采样纹理存储，大致多耗费33%左右的空间）是一种空间换时间的方法。</p><p>Unity中使用方法：Texture Type选择Advanced，勾选Generate Mip Maps 即可。以下是渲染效果：</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled21.png" alt="Untitled"></p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled22.png" alt="Untitled"></p><ul><li>材质面版的选项是由shader中的属性条目进行设置的</li><li>MainTex：纹理的缩放与偏移量<ul><li>Tiling（对应代码中的MainTex.xy）:纹理缩放值</li><li>Offset（对应代码中的MainTex.zw）:纹理偏移值</li></ul></li><li>Render Queue：渲染队列，可以看一下渲染队列顺序那一篇博文（关于Unity渲染顺序）</li><li>Enable GPU Instancing：高效渲染大量相似物体或粒子的技术。通过合并相同材质和属性的物体或粒子，并以单个绘制调用的方式发送给GPU，从而减少了CPU与GPU之间的数据传输和渲染开销。（降低draw call的手段之一）</li><li>Gouble Sided Global Illumination：双面全局照明，指定光照贴图是否在计算全局光照时考虑几何体的两面。设置为 true 时，如果使用渐进光照贴图，则背面将使用与正面相同的发射和反照率来反射光。</li></ul><h3 id="凹凸映射（高度图，法线纹理）"><a href="#凹凸映射（高度图，法线纹理）" class="headerlink" title="凹凸映射（高度图，法线纹理）"></a>凹凸映射（高度图，法线纹理）</h3><p>实现凹凸映射的两种方法，但两者一般一起使用（丰富表面凹凸额外信息——光照）：</p><ul><li><strong>高度映射</strong>：使用一张<strong>高度纹理</strong>来模拟表面位移，然后得到一个修改后的法线值</li><li><strong>法线映射</strong>：使用一张<strong>法线纹理</strong>来存储表面法线</li></ul><p><strong><code>法线映射：</code></strong></p><ul><li>法线方向的分量范围是[-1,1]，像素的分量范围是[0,1]（以像素形式存储）。所以需要进行映射。公式如下：  $pixel=（normal+1）/2$</li><li>在shader中对法线纹理采样之后还需要进行一次反映射，公式如下：  $normal=pixel*2-1$</li></ul><p>Unity内置函数能够提供这部分计算。</p><p><strong><code>采用的法线纹理：</code></strong></p><p>法线是矢量，所以法线的保存通常是需要找到是哪一个空间的矢量，才有意义：</p><ul><li>模型空间的法线纹理：（以模型为中心）模型顶点自带的法线，是定义在模型空间中的，所以将修改后模型空间的表面法线存储在一张纹理中，称为模型空间的法线纹理。</li><li>切线空间的法线纹理（<strong>使用</strong>）：（以顶点为中心）z轴为法线方向，x轴为顶点切线方向，y轴是x轴与z轴叉乘得到的，称为副切线或副法线。如图。</li></ul><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled23.png" alt="Untitled"></p><p>模型空降存储法线优点：</p><ul><li>实现简单</li><li>纹理坐标的缝合处和尖锐的边角部分，突变（缝隙）减少，可以提供跟平滑的边界。</li></ul><p>切线空间存储法线优点：</p><ul><li>自由度高，模型空间下的法线信息是<strong>绝对法线信息</strong>，只能够用于创建他的模型。切线空间上的是<strong>相对法线信息</strong>，用在不用网格上能得到较为合理的结果。</li><li>可以进行UV动画，可以移动纹理的UV坐标实现凹凸移动的效果（水面），模型空间的法线纹理会完全错误，原因同上。</li><li>可以重用法线纹理，一个砖块，使用一张法线纹理就能够用到所有的6个面</li><li>可压缩，切线空间的法线纹理的法线的z方向总是正方向，因此能够仅存储xy，推导得到z。</li></ul><p>以下是切线空间的凹凸渲染</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">//纹理</span></span><br><span class="line">_MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"><span class="comment">//法线纹理“bump”是内置法线纹理</span></span><br><span class="line">_BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line"><span class="comment">//用来控制凸凹程度（法线），为0时，法线不对光照造成任何影响</span></span><br><span class="line">_BumpScale (&quot;Bump Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">_Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">_Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pass &#123; </span><br><span class="line">......</span><br><span class="line">CGPROGRAM</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性描述</span></span><br><span class="line">fixed4 _Color;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主纹理与主纹理缩放偏移</span></span><br><span class="line"><span class="type">sampler2D</span> _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line"><span class="comment">//法线纹理与法线纹理缩放偏移</span></span><br><span class="line"><span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">float4 _BumpMap_ST;</span><br><span class="line"><span class="comment">//用来控制凸凹程度（法线），为0时，法线不对光照造成任何影响</span></span><br><span class="line"><span class="type">float</span> _BumpScale;</span><br><span class="line"></span><br><span class="line">fixed4 _Specular;</span><br><span class="line"><span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点空间是顶点法线（已知）与切线构建出的空间，这里需要获取切线方向</span></span><br><span class="line">struct a2v &#123;</span><br><span class="line">float4 vertex : POSITION;</span><br><span class="line">float3 normal : NORMAL;</span><br><span class="line"><span class="comment">//切线方向</span></span><br><span class="line">float4 tangent : TANGENT;</span><br><span class="line">float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要在顶点着色器中计算切线空间的光照与视角</span></span><br><span class="line">struct v2f &#123;</span><br><span class="line">float4 pos : SV_POSITION;</span><br><span class="line">float4 uv : TEXCOORD0;</span><br><span class="line">float3 lightDir: TEXCOORD1;</span><br><span class="line">float3 viewDir : TEXCOORD2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//uv的xy分量存储第一张纹理_MainTex的纹理坐标</span></span><br><span class="line">o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line"><span class="comment">//uv的zw分量存储法线纹理_BumpMap的纹理坐标</span></span><br><span class="line">o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line"><span class="comment">//副切线</span></span><br><span class="line">float3 binormal = <span class="built_in">cross</span>( <span class="built_in">normalize</span>(v.normal), <span class="built_in">normalize</span>(v.tangent.xyz) ) * v.tangent.w;</span><br><span class="line"><span class="comment">//将模型空间的切线方向、副切线方向与法线方向安行排列,得到模型空间=&gt;切线空间的变换矩阵</span></span><br><span class="line">float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal);</span><br><span class="line"><span class="comment">//unity内置方法在下方，直接计算模型空间=&gt;切线空间的变换矩阵,存储到rotation</span></span><br><span class="line"><span class="comment">//TANGENT_SPACE_ROTATION;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取切线空间的光源</span></span><br><span class="line">o.lightDir = mul(rotation, <span class="built_in">normalize</span>(ObjSpaceLightDir(v.vertex))).xyz;</span><br><span class="line"><span class="comment">//获取切线空间的视角</span></span><br><span class="line">o.viewDir = mul(rotation, <span class="built_in">normalize</span>(ObjSpaceViewDir(v.vertex))).xyz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line"><span class="comment">//切线空间的光源方向与视角方向矢量归一化</span></span><br><span class="line">fixed3 tangentLightDir = <span class="built_in">normalize</span>(i.lightDir);</span><br><span class="line">fixed3 tangentViewDir = <span class="built_in">normalize</span>(i.viewDir);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行法线纹理采样</span></span><br><span class="line">fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">fixed3 tangentNormal;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法线纹理存储的是法线经过映射之后的像素值。需要将其反映射回来</span></span><br><span class="line"><span class="comment">// 如果unity中没有设置法线纹理为Normal map类型，就需要在代码中进行反映射</span></span><br><span class="line"><span class="comment">//tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale;</span></span><br><span class="line"><span class="comment">//tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));</span></span><br><span class="line"><span class="comment">//unity内置方法</span></span><br><span class="line">tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">tangentNormal.xy *= _BumpScale;</span><br><span class="line"><span class="comment">//切线空间的法线z分量，由xy分量获得</span></span><br><span class="line"><span class="comment">//saturate函数限制数值范围在[0,1]中</span></span><br><span class="line">tangentNormal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用纹理对漫反射颜色进行采样</span></span><br><span class="line">fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line"><span class="comment">//环境光</span></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line"><span class="comment">//漫反射</span></span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, tangentLightDir));</span><br><span class="line"></span><br><span class="line"><span class="comment">//高光反射，blinn模型</span></span><br><span class="line">fixed3 halfDir = <span class="built_in">normalize</span>(tangentLightDir + tangentViewDir);</span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下是世界空间的凹凸渲染</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//凹凸，世界空间——法线纹理</span></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Normal Map In World Space&quot; &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line">_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//贴图与法线贴图以及法线凹凸系数</span></span><br><span class="line">_MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">_BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">_BumpScale (&quot;Bump Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">_Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">_Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">SubShader &#123;</span><br><span class="line">Pass &#123; </span><br><span class="line">Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">CGPROGRAM</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma vertex vert</span></span><br><span class="line"><span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">fixed4 _Color;</span><br><span class="line"></span><br><span class="line"><span class="type">sampler2D</span> _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line"><span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">float4 _BumpMap_ST;</span><br><span class="line"><span class="type">float</span> _BumpScale;</span><br><span class="line"></span><br><span class="line">fixed4 _Specular;</span><br><span class="line"><span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">struct a2v &#123;</span><br><span class="line">float4 vertex : POSITION;</span><br><span class="line">float3 normal : NORMAL;</span><br><span class="line">float4 tangent : TANGENT;</span><br><span class="line">float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f &#123;</span><br><span class="line">float4 pos : SV_POSITION;</span><br><span class="line">float4 uv : TEXCOORD0;</span><br><span class="line"><span class="comment">//注意这里计算的是世界空间的凹凸纹理</span></span><br><span class="line"><span class="comment">//这里是存储了切线空间到世界空间的转换矩阵</span></span><br><span class="line">float4 TtoW0 : TEXCOORD1;  </span><br><span class="line">float4 TtoW1 : TEXCOORD2;  </span><br><span class="line">float4 TtoW2 : TEXCOORD3;*</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对纹理坐标进行缩放与平移</span></span><br><span class="line">o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line"><span class="comment">//世界空间顶点</span></span><br><span class="line">float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line"><span class="comment">//世界空间法线</span></span><br><span class="line">fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line"><span class="comment">//世界空间切线</span></span><br><span class="line">fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line"><span class="comment">//世界空间副切线</span></span><br><span class="line">fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 摆放世界空间法线，世界空间切线，世界空间副切线得到切线空间到设计空间的变换矩阵</span></span><br><span class="line"><span class="comment">// 保存世界空间顶点xyz（利用存储空间，保存世界空间坐标）</span></span><br><span class="line">o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);</span><br><span class="line">o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);</span><br><span class="line">o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);**</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line"><span class="comment">// 获取世界空间顶点坐标</span></span><br><span class="line">float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line"><span class="comment">// 获取世界空间光源与视角</span></span><br><span class="line">fixed3 lightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取切线空间的法线，使用UnpackNormal进行法线贴图采样与解码（将法线纹理标格式识成Normal map）</span></span><br><span class="line">fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line"><span class="comment">//通过_BumpScale对法线进行缩放</span></span><br><span class="line">bump.xy *= _BumpScale;</span><br><span class="line">bump.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(bump.xy, bump.xy)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//将法线从切线空间转换到世界空间</span></span><br><span class="line">bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//纹理材质采样</span></span><br><span class="line">fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line"><span class="comment">//环境光</span></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line"><span class="comment">//漫反射</span></span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, lightDir));</span><br><span class="line"></span><br><span class="line">fixed3 halfDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意，如果使用UnpackNormal函数来进行法线贴图的法线获取。需要将法线贴图设置成Normal map类型。这是因为设置成Normal map类型后，unity会根据不同平台对纹理进行压缩（如DZT5nm格式会省略z轴，通过xy轴求）。之后在通过UnpackNormal解压缩并获取正确的法线。</li></ul><h3 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h3><ul><li>一种冷到暖色调的着色技术（插画风格的渲染效果）</li></ul><p>以下是三种渐变纹理的区别：</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled24.png" alt="Untitled"></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//渐变纹理</span></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Ramp Texture&quot; &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line">_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">**<span class="comment">//渐变纹理</span></span><br><span class="line">_RampTex (&quot;Ramp Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;**</span><br><span class="line">_Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">_Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">SubShader &#123;</span><br><span class="line">Pass &#123; </span><br><span class="line">Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">CGPROGRAM</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma vertex vert</span></span><br><span class="line"><span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">fixed4 _Color;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义渐变纹理与渐变纹理缩放平移</span></span><br><span class="line"><span class="type">sampler2D</span> _RampTex;</span><br><span class="line">float4 _RampTex_ST;</span><br><span class="line"></span><br><span class="line">fixed4 _Specular;</span><br><span class="line"><span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器数据输入</span></span><br><span class="line">struct a2v &#123;</span><br><span class="line">float4 vertex : POSITION;</span><br><span class="line">float3 normal : NORMAL;</span><br><span class="line"><span class="comment">//第一组纹理（输入的纹理）</span></span><br><span class="line">float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f &#123;</span><br><span class="line"><span class="comment">//投影空间顶点</span></span><br><span class="line">float4 pos : SV_POSITION;</span><br><span class="line">float3 worldNormal : TEXCOORD0;</span><br><span class="line">float3 worldPos : TEXCOORD1;</span><br><span class="line">float2 uv : TEXCOORD2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line"></span><br><span class="line">o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TRANSFORM_TEX,计算平铺与平移之后的纹理坐标</span></span><br><span class="line">o.uv = TRANSFORM_TEX(v.texcoord, _RampTex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line"><span class="comment">//获得世界空间光源</span></span><br><span class="line">fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line"><span class="comment">//环境光</span></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 半兰伯特模型（控制显示范围）</span></span><br><span class="line">fixed halfLambert  = <span class="number">0.5</span> * <span class="built_in">dot</span>(worldNormal, worldLightDir) + <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">//获取漫反射颜色（通过纹理采样获取）</span></span><br><span class="line">fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line"><span class="comment">//_LightColor0顶点光源强度与漫反射强度得到漫反射效果</span></span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * diffuseColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高光反射，blinn模型</span></span><br><span class="line">fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在片元着色器中使用半兰伯特模型对法线方向与光照方向的点积进行一次半兰伯特计算，映射了显示范围。<ul><li>个人推测，避免兰伯特光照造成的背光模型无变化（不符合渐变纹理显示效果），所以使用半兰伯特模型</li></ul></li><li>由_RampTex纹理图片可以看出，这是一个横轴颜色逐渐变化，重轴颜色相同的纹理。所以使用半兰伯特部分构建一维纹理坐标，对_RampTex纹理进行采样。（fixed2(halfLambert, halfLambert)）</li><li>需要注意：进行纹理采样的时候，需要将渐变纹理的Wrap Mode模式设置成Clamp模式，防止纹理采样由于浮点数精度造成的问题。</li></ul><h3 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h3><ul><li>用来控制部分区域不同于其他区域的显示效果</li><li>遮罩纹理流程：通过采样获取遮罩纹理的值，使用其中某个（或某几个）通道的值与某种表面属性相乘（改通道值为0时，表面不受该属性影响）</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"><span class="comment">//遮罩纹理</span></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Mask Texture&quot; &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line">_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">//主纹理</span></span><br><span class="line">_MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"><span class="comment">//法线纹理与法线凹凸缩放</span></span><br><span class="line">_BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">_BumpScale(&quot;Bump Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line"><span class="comment">//遮罩纹理与遮罩缩放</span></span><br><span class="line">_SpecularMask (&quot;Specular Mask&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">_SpecularScale (&quot;Specular Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">_Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">_Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">SubShader &#123;</span><br><span class="line">Pass &#123; </span><br><span class="line">Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">CGPROGRAM</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma vertex vert</span></span><br><span class="line"><span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">fixed4 _Color;</span><br><span class="line"><span class="comment">//主纹理与纹理缩放</span></span><br><span class="line"><span class="type">sampler2D</span> _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line"><span class="comment">//法线纹理与纹理缩放</span></span><br><span class="line"><span class="type">sampler2D</span> _BumpMap;</span><br><span class="line"><span class="type">float</span> _BumpScale;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遮罩纹理与缩放（是用来控制高光反射效果的）</span></span><br><span class="line"><span class="type">sampler2D</span> _SpecularMask;</span><br><span class="line"><span class="type">float</span> _SpecularScale;**</span><br><span class="line"></span><br><span class="line">fixed4 _Specular;</span><br><span class="line"><span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器输入：模型空间顶点、法线、切线、第一张纹理</span></span><br><span class="line">struct a2v &#123;</span><br><span class="line">float4 vertex : POSITION;</span><br><span class="line">float3 normal : NORMAL;</span><br><span class="line">float4 tangent : TANGENT;</span><br><span class="line">float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点输出与片元着色器输入：顶点位置、uv纹理、光源、视角</span></span><br><span class="line">struct v2f &#123;</span><br><span class="line"><span class="comment">//剪裁空间</span></span><br><span class="line">float4 pos : SV_POSITION;</span><br><span class="line">float2 uv : TEXCOORD0;</span><br><span class="line"><span class="comment">//切线空间</span></span><br><span class="line">float3 lightDir: TEXCOORD1;</span><br><span class="line">float3 viewDir : TEXCOORD2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line">v2f o;</span><br><span class="line"><span class="comment">//模型空间顶点=&gt;剪裁空间顶点</span></span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"><span class="comment">//对第一张纹理进行采样（缩放平移）</span></span><br><span class="line">o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unity内置方法，直接计算模型空间=&gt;切线空间的变换矩阵,存储到rotation</span></span><br><span class="line">TANGENT_SPACE_ROTATION;</span><br><span class="line"><span class="comment">//获得切线空间的光源与视角</span></span><br><span class="line">o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line"><span class="comment">//切线空间光源视角归一化</span></span><br><span class="line"> fixed3 tangentLightDir = <span class="built_in">normalize</span>(i.lightDir);</span><br><span class="line">fixed3 tangentViewDir = <span class="built_in">normalize</span>(i.viewDir);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得切线空间法线，纹理采样与解码</span></span><br><span class="line">fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uv));</span><br><span class="line">tangentNormal.xy *= _BumpScale;</span><br><span class="line">tangentNormal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//主纹理材质采样</span></span><br><span class="line">fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line"><span class="comment">//环境光</span></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"><span class="comment">//漫反射</span></span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, tangentLightDir));</span><br><span class="line"></span><br><span class="line"><span class="comment">//blinn模型，视角与入射光源的平分线</span></span><br><span class="line"> fixed3 halfDir = <span class="built_in">normalize</span>(tangentLightDir + tangentViewDir);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//遮罩纹理采样（本纹理，三个通道数值相同步，rgb三个通道只使用了r通道）</span></span><br><span class="line"> fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//高光反射——高光反射结果乘以遮罩纹理采样数据</span></span><br><span class="line"> fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, halfDir)), _Gloss) * specularMask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是效果对比：</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled25.png" alt="Untitled"></p><hr><h2 id="透明测试、混合与面剔除"><a href="#透明测试、混合与面剔除" class="headerlink" title="透明测试、混合与面剔除"></a>透明测试、混合与面剔除</h2><p>透明效果是游戏中最常见的效果之一。在unity中，实现透明效果有2种方式，分别是完全透明的透明度测试以及会混合前后颜色，实现半透明效果的透明度混合。透明度测试相对简单，这也是因为透明度测试实现的是完全透明效果，不用关闭深度写入，效果极端；而透明度混合则相对复杂，主要原因还是因为关闭了深度写入，导致的一些由于渲染顺序或物体相互之间的层级引起的一些问题。所以首先我们要先来了解一下深度写入与渲染顺序的概念。</p><h3 id="深度写入与渲染顺序"><a href="#深度写入与渲染顺序" class="headerlink" title="深度写入与渲染顺序"></a>深度写入与渲染顺序</h3><p>深度写入：用于判断物体遮挡情况下需要渲染的颜色。将深度数值写入深度缓冲区，在深度测试的时候，在颜色缓冲区将深度小的像素的颜色替换深度大的物体的深度颜色。这样就能够渲染出离摄像机更近的物体颜色。</p><ul><li>关闭<strong>深度写入</strong>：需要注意的是，透明度混合是由<code>透明物体的颜色</code>以及<code>透明物体之后的物体颜色</code>组合成的。其中透明物体之后的物体颜色存储在存储在颜色缓冲区。如果不关闭深度写入，在进行深度测试的时候，之后的物体由于深度更大，会因为深度写入将原本存储在颜色缓冲区的物体表面颜色数值剔除掉。就无法进行透明度混合了。（之后的物体颜色丢失）<ul><li>简单来说，两个物体如果都有深度值，就会进行深度检测，导致颜色缓冲区的颜色被替代。</li><li>关闭深度写入，颜色缓冲区就有之后物体的颜色，与当前半透明物体的颜色混合，就有了混合效果的颜色。</li></ul></li><li>渲染顺序：由于关闭了深度写入，所以无法判断物体里摄像机远近，所以渲染时需要注意物体的渲染顺序，先渲染不透明物体，在渲染半透明物体。以下是个渲染效果说明：<ul><li>存在半透明物体A，在前；不透明物体B，在后。（都为半透明也同理）</li><li>正确渲染效果：先渲染物体B，再渲染物体A。不透明物体B开启了深度测试与深度写入，此时深度缓冲区没有数值，B将自己的深度写入深度缓冲区，颜色写入颜色缓冲区。再渲染半透明物体A，由于物体A关闭深度写入，只有深度检测。深度检测物体A里摄像机更近，读取颜色缓冲区B的颜色，与物体A颜色混合，达成半透明效果。</li><li>错误渲染效果：先渲染物体A，再渲染物体B。半透明物体A只开启了深度测试，没有深度写入，此时深度缓冲区没有数值也不写入，A将自己的颜色写入颜色缓冲区。再渲染不透明物体B，由于B开启了深度检测与深度写入。同时发现深度缓冲区内没有深度值，B会直接修改颜色缓冲区中的颜色（为B的颜色），A的颜色被覆盖丢失，最后屏幕上渲染出B的颜色（看起来B在A之前，也就是没有混合，只有B的颜色）。</li></ul></li></ul><p>至于Unity的渲染顺序，有需要的可以参考<a href="https://the-black-sun.github.io/2023/09/05/Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/">Unity渲染顺序探究 | 墨墨辰的旋转小屋 (the-black-sun.github.io)</a>的简要说明。需要注意的是：</p><ul><li>先渲染所有不透明物体，并开启深度测试与深度写入</li><li>将半透明物体安距离摄像机远近排序，然后从后往前渲染，并开启深度测试，关闭深度写入</li></ul><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>虽然有深度测试与渲染顺序的调整存在，但是仍然存在一个问题：单个重叠物体或多个相互重叠物体会导致混合效果错误。存在物体相互堆叠的情况，存在物体的部分区域的渲染前后排序顺序不一致的情况，但是调整渲染顺序无法解决这一个问题。因为根据深度进行渲染顺序调整是以物体为单位进行的，而深度测试与深度写入是以像素点为单位进行的。面对这种情况，UnityShader通常使用两个Pass进行解决（一个进行混合操作，一个进行深度写入，注意关闭深度写入的相关操作也在Pass中进行）。</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled26.png" alt="Untitled"></p><h3 id="UnityShader的渲染队列"><a href="#UnityShader的渲染队列" class="headerlink" title="UnityShader的渲染队列"></a>UnityShader的渲染队列</h3><p>上述由于物体堆叠导致的渲染顺序问题，Unity通过渲染队列来进行解决。SubShader的<code>Queue</code>标签可以决定模型改归于哪一个渲染队列，索引号越小表示越早被渲染。渲染队列有以下几种：</p><table><thead><tr><th>名称</th><th>队列索引号(RenderQueue)</th><th>描述</th></tr></thead><tbody><tr><td>Background</td><td>1000</td><td>该队列在其他所有队列之前被渲染，通常用来渲染需要被绘制在背景上的物体</td></tr><tr><td>Geometry</td><td>2000</td><td>默认渲染队列，大多数物体使用的队列，不透明物体使用的队列</td></tr><tr><td>AlphaTest</td><td>2450（小于2500为完全不透明）</td><td>需要进行透明度测试的物体使用的队列。</td></tr><tr><td>Transparent</td><td>3000</td><td>该队列中的物体会在前两个队列（Geometry与AlphaTest）渲染之后，再根据从后往前的顺序进行渲染，所有使用了透明度混合的物体使用该队列。</td></tr><tr><td>Overlay</td><td>4000</td><td>该队列用来实现叠加效果，需要在最后渲染的物体使用这个队列</td></tr></tbody></table><p>以下是UnityShader中的渲染队列设置：</p><ul><li>透明度测试  <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">Tags&#123;&quot;Queue&quot;=&quot;AlphaTest&quot;&#125;</span><br><span class="line">Pass&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>透明度混合  <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">Pass&#123;</span><br><span class="line">ZWrite Off</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>接下来来看一下透明度测试与透明度混合的具体效果实现。</p><h3 id="透明度测试"><a href="#透明度测试" class="headerlink" title="透明度测试"></a>透明度测试</h3><p>实现的是完全透明或完全不透明效果。需要用到一个由CG提供的透明度测试函数clip，如下所示：</p><ul><li>函数：void clip(float<strong>X</strong>  x)⇒<code>X代表数字无~4</code></li><li>参数：剪裁时使用的标量或矢量条件</li><li>描述：如果给定参数的任何一个分量是负数，就会舍弃当前像素的输出颜色</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> clip(float4 x)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">any</span>(x&lt;<span class="number">0</span>))</span><br><span class="line"><span class="keyword">discard</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是透明度测试的部分代码：没有通过透明度测试的像素直接舍弃掉（discard）。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">8</span>/Alpha Test&quot; &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line"><span class="comment">//颜色与纹理等属性</span></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">//像素透明度参数</span></span><br><span class="line">_Cutoff (&quot;Alpha Cutoff&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">&#125;</span><br><span class="line">SubShader &#123;</span><br><span class="line"><span class="comment">//Queue设置为透明度测试；</span></span><br><span class="line"><span class="comment">//IgnoreProjector设置为true，不收到投影器影响；</span></span><br><span class="line"><span class="comment">//RenderType类型，该shader加入Transparent组</span></span><br><span class="line">Tags &#123;&quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;&#125;</span><br><span class="line"></span><br><span class="line">Pass &#123;</span><br><span class="line">....</span><br><span class="line"><span class="comment">//透明度参数</span></span><br><span class="line">fixed _Cutoff;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">//纹理采样与解码</span></span><br><span class="line">fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alpha test  开启透明度测试</span></span><br><span class="line">clip (texColor.a - _Cutoff);</span><br><span class="line"><span class="comment">// Equal to </span></span><br><span class="line"><span class="comment">// if ((texColor.a - _Cutoff) &lt; 0.0) &#123;</span></span><br><span class="line"><span class="comment">//discard;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">FallBack &quot;Transparent/Cutout/VertexLit&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h3><p>透明度混合能够实现真正的半透明效果。透明度混合需要通过Blend命令进行逐片元透明混合设置，主要的Blend命令如下：</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled27.png" alt="Untitled"></p><p>由上图可以看出第2种和第3种命令存在着混合因子这个概念，这个混合因子是为了控制两种颜色的混合比例而产生的。其中第2种混合命令，提供两个混合因子用来控制两个混合颜色的混合比例，RGB与A通道的混合因子相同；第3种提供了四个混合因子，多出来的两个分别用来里控制两种颜色的透明度通道，RGB与A通道的混合因子不同。</p><p>同时以下是SubShader中支持的混合因子：</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled28.png" alt="Untitled"></p><p>除此之外还有SubShader支持的混合操作（前后两种颜色混合方式）以及常见的混合类型，通过<code>BlendOp命令</code>进行修改：</p><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>Add</td><td>将混合后的源颜色与混合后的目的颜色相加。是默认的混合操作，等式如下：O=SrcFactor<em>S+DstFactor</em>D</td></tr><tr><td>Sub</td><td>将混合后的源颜色减去混合后的目的颜色。O=SrcFactor<em>S-DstFactor</em>D</td></tr><tr><td>RevSub</td><td>将混合后的目的颜色减去混合后的源颜色。O=DstFactor<em>D-SrcFactor</em>S</td></tr><tr><td>Min</td><td>使用源颜色和目的颜色中较小的值，每个分量都进行比较。</td></tr><tr><td>Max</td><td>使用源颜色和目的颜色中较大的值，每个分量都进行比较。</td></tr><tr><td>其他逻辑操作</td><td>仅仅DX11支持</td></tr></tbody></table><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意指令格式,SrcFactor、DstFactor以及SrcFactorA和DstFactorA都能用以上混合因子表中的值代替，如下</span></span><br><span class="line">Blend SrcFactor DstFactor</span><br><span class="line">Blend SrcFactor DstFactor,SrcFactorA DstFactorA</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常（Normal），透明度混合</span></span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line"><span class="comment">//柔和相加</span></span><br><span class="line">Blend OneMinusDstColor One</span><br><span class="line"></span><br><span class="line"><span class="comment">//正片叠底，即相乘</span></span><br><span class="line">Blend DstColor Zero</span><br><span class="line"></span><br><span class="line"><span class="comment">//两倍相乘</span></span><br><span class="line">Blend DstColor SrcColor</span><br><span class="line"></span><br><span class="line"><span class="comment">//变暗，注意这里的混合因子无用，max也相同</span></span><br><span class="line">BlendOp Min</span><br><span class="line">Blend One One</span><br><span class="line"></span><br><span class="line"><span class="comment">//变亮</span></span><br><span class="line">BlendOp Max</span><br><span class="line">Blend One One</span><br><span class="line"></span><br><span class="line"><span class="comment">//滤色</span></span><br><span class="line">Blend OneMinusDstColor One</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Blend One OneMinusSrcColor</span><br><span class="line"></span><br><span class="line"><span class="comment">//线性减淡 </span></span><br><span class="line">Blend One One</span><br></pre></td></tr></table></figure><p>下面是最常见的混合计算公式（一般而言是按透明度进行混合的，但是可以根据混合命令进行设置）：</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled29.png" alt="Untitled"></p><ul><li>DstColor：颜色缓冲区的颜色</li><li>SrcAlpha：原颜色的混合因子：SrcFactor。可能是原颜色的透明度。</li><li>SrcColor：原颜色</li><li>DstColor：目标颜色；原本颜色缓冲区颜色</li><li>（1-SrcAlpha）：DstFactor，目标颜色的混合因子</li><li>注意：修改公式内容可以得到其他类型的混合公式与混合效果</li></ul><p>以下是透明度混合的部分部分UnityShader代码设置：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于透明度混合是（逐片元）可配置的，并非完全可编程的，所以只需要在Shader中设置好混合命令即可。</span></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">8</span>/Alpha Blend&quot; &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">//像素半透明参数</span></span><br><span class="line">_AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">SubShader &#123;</span><br><span class="line"><span class="comment">//Queue设置为半透明Transparent</span></span><br><span class="line">Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line"></span><br><span class="line">Pass &#123;</span><br><span class="line">....</span><br><span class="line"><span class="comment">//关闭深度写入</span></span><br><span class="line">ZWrite Off</span><br><span class="line"><span class="comment">//设置透明混合命令</span></span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">fixed _AlphaScale;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">....</span><br><span class="line"><span class="comment">//返回最后的合成颜色，并设置透明度通道=纹理像素的透明通道*材质参数_AlphaScale</span></span><br><span class="line"><span class="keyword">return</span> fixed4(ambient + diffuse, texColor.a * _AlphaScale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开启深度写入的半透明效果"><a href="#开启深度写入的半透明效果" class="headerlink" title="开启深度写入的半透明效果"></a>开启深度写入的半透明效果</h2><p>还记得之前在<code>存在的问题</code>小节中提到的问题吗？不同物体部分区域前后位置不一致导致的混合效果错误现象，是由于深度写入关闭的原因，解决方法就是开启深度写入了（- -“）。之前说了，之所以关闭深度写入是因为避免深度写入之后，将颜色缓冲区的旧颜色（目标颜色，后面物体的颜色）替换成深度较浅的前面物体的颜色。所以这里说的开启深度写入指的是将深度写入深度缓冲区，但是不进行包括颜色替换的其他任何操作。在实际实现中表现为单独使用一个Pass进行深度写入操作。部分代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">8</span>/Alpha Blend&quot; &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">//像素半透明参数</span></span><br><span class="line">_AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">SubShader &#123;</span><br><span class="line"><span class="comment">//Queue设置为半透明Transparent</span></span><br><span class="line">Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只进行深度写入</span></span><br><span class="line">Pass &#123;</span><br><span class="line"><span class="comment">//打开深度写入</span></span><br><span class="line">ZWrite On</span><br><span class="line"></span><br><span class="line"><span class="comment">//渲染命令ColorMask，用于设置颜色通道的写掩码（write mask）</span></span><br><span class="line"><span class="comment">//语义:ColorMask RGB|A|0|其他RGBA的组合</span></span><br><span class="line"><span class="comment">//以下表示，该Pass不写入任何颜色通道，不会输出任何颜色</span></span><br><span class="line">ColorMask <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pass &#123;</span><br><span class="line">Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"><span class="comment">//关闭深度写入</span></span><br><span class="line">ZWrite Off</span><br><span class="line"><span class="comment">//设置透明混合命令</span></span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line"><span class="comment">//其余部分操作与透明度混合相同</span></span><br><span class="line">....</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：这种深度写入能够完成不同顺序的物体之间的混合效果，但是在同一物体的遮挡混合中不能够实现混合，具体效果可以查看下方效果展示中的<code>透明度混合，深度写入</code>，除此之外，在透明效果中还需要注意透明应该需要能够看见当前透明物体的内部结构，这就需要使用到剔除的功能了，同样经过测试，开启了深度写入的同物体也不能展示双面不被剔除的显示效果（也就是关闭剔除之后，开启深度写入，没办法展示出<code>双面</code>的效果，反而与开启剔除效果相同），具体原因待探究。</p><h3 id="双面渲染的透明效果"><a href="#双面渲染的透明效果" class="headerlink" title="双面渲染的透明效果"></a>双面渲染的透明效果</h3><p>如果物体有透明效果。那么不但应该能够透过它看见其他物体的样子，还应该能够看见物体的内部结构。但是以上的渲染效果并不会实现这些功能，导致渲染的透明或半透明物体看上去只是半个物体（背面的半个消失了，如下图）</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled30.png" alt="Untitled"></p><p>这是因为物体渲染的时候开启了剔除（cull）功能，并且默认设置成了Back。让背对摄像机，摄像机看不见的部分不进行渲染。所以造成了透明效果的穿帮。</p><ul><li>Cull Back：开启背面剔除</li><li>Cull Front：开启正面剔除</li><li>Cull Off：关闭剔除</li></ul><p>以下是透明度测试的双面剔除的部分代码,效果展示可以再本节最下方查看：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭剔除功能</span></span><br><span class="line">Cull Off</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>透明度测试的剔除很简单，但是透明度混合不能够向透明度测试一样操作。这是因为透明度混合关闭了深度写入，为了保证同一个物体的渲染顺序，需要分成两个Pass分别进行正面剔除的渲染与背面剔除的渲染。部分代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">8</span>/Alpha Blend With Both Side&quot; &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line">....</span><br><span class="line">_AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">SubShader &#123;</span><br><span class="line">Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line"></span><br><span class="line">Pass &#123;</span><br><span class="line">Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First pass renders only back faces </span></span><br><span class="line">Cull Front</span><br><span class="line"></span><br><span class="line">ZWrite Off</span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pass &#123;</span><br><span class="line">Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Second pass renders only front faces </span></span><br><span class="line">Cull Back</span><br><span class="line"></span><br><span class="line">ZWrite Off</span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本章实现的透明效果如下：</p><p><img src="../UnityShader%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%88%9D%E7%BA%A7%E7%AF%87/Untitled31.png" alt="Untitled"></p><hr><h2 id="问题探究"><a href="#问题探究" class="headerlink" title="问题探究"></a>问题探究</h2><p>等unityShader总结全部整理好之后，会归纳一下可能不太熟悉的知识点或问题，看看能不能出个问题总结。这里先记录一下这部分内容学习遇上的问题，各位大佬有了解的也可以尝试在评论区进行评论。</p><ol><li>透明混合效果的阴影实现</li><li>开启深入写入的本物体无法进行透明混合，原因与是否有解决方法</li><li>uv坐标与tex2d（）的采样原理</li><li>UnityShader中定义的属性存储语义（这里指的是结构体中的POSITION等等）以及属性（这里指的是属性）相关的声明类型。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Shader </tag>
            
            <tag> 图形渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua学习总结</title>
      <link href="/2023/09/06/Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2023/09/06/Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>2023年10月1日更新</p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作一直在写 Lua 相关的游戏逻辑脚本，但一直没做个总结，前端时间看了一下 Lua 语言的底层逻辑，做个记录总结让以后可以拿出来翻翻看。文章有点长，可以通过索引查找对应内容。</p><hr><h2 id="Lua-的底层与编译"><a href="#Lua-的底层与编译" class="headerlink" title="Lua 的底层与编译"></a>Lua 的底层与编译</h2><h3 id="语言类型与区别"><a href="#语言类型与区别" class="headerlink" title="语言类型与区别"></a>语言类型与区别</h3><p>Lua 语言是以 C 语言为底层的<code>脚本语言</code>（动态语言，运行时编译），与 C 语言，C++等<code>静态语言</code>（静态语言，运行前编译）不同。其中 Lua 的执行主要运行流程如下：</p><ul><li>程序员编辑 Lua 脚本代码，保存.lua 文件</li><li>语法词法分析，并生成指令集（*lua.byte 文件），属于编译过程</li><li>Lua 虚拟机执行指令集，属于执行过程</li><li>输出结果</li></ul><p>这里放一张由大佬（<strong>烟雨迷离半世殇</strong>）做的对比表格：</p><table><thead><tr><th>语言</th><th>编辑</th><th>预编译</th><th>运行时编译</th><th>执行</th></tr></thead><tbody><tr><td>Lua</td><td>编写 lua 文件</td><td>无</td><td>虚拟机读取字节码并转换成虚拟机指令，汇编器编译成机器码</td><td>CPU 执行机器码</td></tr><tr><td>C#</td><td>编写 cs 文件</td><td>被 C#编译器编译成 dll，包含 IL 代码</td><td>CLR 使用 JIT 编译把 IL 转换成机器码</td><td>CPU 执行机器码</td></tr></tbody></table><h3 id="Lua-语言编译原理"><a href="#Lua-语言编译原理" class="headerlink" title="Lua 语言编译原理"></a>Lua 语言编译原理</h3><p>Lua 语言的的编译，首先需要明白代码块（chunk），闭包（closure），和原型（proto）的关系。</p><ol><li>chunk：代码块，一段符合 Lua 语法的代码。</li><li>closure：Lua 运行期间的一个实例对象，在运行期间调用的大多是一个 closure。</li><li>proto：（原型）Lua 语言中 closure 的原型（类似与 C++中对象声明与实例的关系），定义了有关代码段的大部分信息，包括：<ul><li>指令列表：包含了函数编译后生成的<code>虚拟机指令</code>。</li><li>常量表：这个函数运行期需要的<code>所有常量</code>，在指令中，常量使用常量表 id 进行索引。</li><li>子 proto 表：所有内嵌于这个函数的<code>proto列表</code>，在 OP_CLOSURE 指令中的 proto id 就是索引的这个表。</li><li>局部变量描述：这个函数使用到的<code>所有局部变量名称，以及生命期</code>。由于<code>所有的局部变量运行期都被转化成了寄存器id</code>，所以这些信息只是 debug 使用。</li><li>Upvalue 描述：upvalue 是内嵌函数中能够访问到的外包函数中的局部变量；称为外部局部变量感觉更为贴切。在创建 closure 时（创建函数实例）初始化 Upvalue。</li></ul></li></ol><p>每一个 proto 在运行期间可以产生多个 closure 对象来表示函数实例。</p><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled.png" alt="Untitled"></p><p>**<code>closure是运行期的对象</code>**，与运行期关系更大；而<code>与编译期相关的其实是proto对象</code>，他才是编译过程真正需要生成的目标对象。</p><h3 id="Lua-语言编译流程"><a href="#Lua-语言编译流程" class="headerlink" title="Lua 语言编译流程"></a>Lua 语言编译流程</h3><ul><li>首先调用<code>lua_load</code> api，将一块符合 lua 语法的代码块<code>Chunk</code>进行编译。</li><li>编译为当前的 Chunk 生成一个<code>mainfunc proto</code>对象，并生成一个父对象<code>mainfunc closure</code>对象放到当前的栈顶中，等待接下来的执行。</li><li>Chunk 内部的每个<code>function statement（函数语句）</code>也都会生成一个对应的<code>子proto</code>，保存在外层函数的子函数列表中（proto 中有子 proto 列表）。</li><li>所有最外层的**<code>function statement</code>**的 proto 会被保存到<code>mainfunc proto</code>的子函数列表中。</li><li>按照层次依次编译，形成一个以<code>mainfunc</code>为根节点的 proto 树。</li></ul><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled1.png" alt="Untitled"></p><hr><h2 id="Lua-的底层数据结构"><a href="#Lua-的底层数据结构" class="headerlink" title="Lua 的底层数据结构"></a>Lua 的底层数据结构</h2><p>只要讲到有关于 Lua 与其他语言交互的过程的相关原理，虚拟机一定是一个不可能绕过的概念。需要注意的是不同于像**<code>C#，java等语言使用的是基于堆栈的虚拟机</code>**，Lua5.0 之后，<code>**Lua语言开始改用基于寄存器的虚拟机</code>。**首先了解一下，Lua 底层数据结构的实现方式。</p><h3 id="C-语言的实现面向对象（注意可能存在-Lua-版本差异）"><a href="#C-语言的实现面向对象（注意可能存在-Lua-版本差异）" class="headerlink" title="C 语言的实现面向对象（注意可能存在 Lua 版本差异）"></a>C 语言的实现面向对象（注意可能存在 Lua 版本差异）</h3><p>由于 Lua 的底层是通过 C 语言进行实现的，所以在设置 Lua 的数据结构的时候，也是通过 C 语言来进行实现。而主要的实现思路是：</p><ul><li>定义一个公共的数据结构作为基础类型，用来存储表达数据的基础信息，其他类型由此派生（<strong>需要注意的是这个基础类型需要包含所有数据的存储方式，通过 Union 进行实现</strong>）。</li><li>使用联合（ union ）来将所有数据包进来，<ul><li><strong>Value</strong>提供基础数据的存储方式（GC 对象，指针，number 与布朗值）以及<strong>GCObject</strong>。</li><li><strong>GCObject</strong>提供所有非基础类型的存储方式（table，string，closure 等），需要进行垃圾回收</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lua_TValue</span> &#123;</span></span><br><span class="line">  Value value_;</span><br><span class="line">  <span class="type">int</span> tt_;         <span class="comment">//数据类型标识，新版11种（下截图），同时使用TValuefields进行表示</span></span><br><span class="line">&#125; TValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">GCObject *gc;    <span class="comment">//上述所有需要进行数据回收的联合体，指针，指向联合体GCObject定义（table，thread，closure等）</span></span><br><span class="line"><span class="type">void</span> *p;         <span class="comment">//轻量级light，userdata，指针</span></span><br><span class="line">lua_CFunction f; <span class="comment">//旧版没有这个。C语言函数</span></span><br><span class="line">lua_Integer i;   <span class="comment">//整形类型，Lua5.1版本中只使用了lua_Number来进行整数和浮点数表示，但范围比int64_t类型小，之后Lua5.3扩充了整形类型来表示整数</span></span><br><span class="line">lua_Number n;    <span class="comment">//默认为double类型，Lua重编译可更换</span></span><br><span class="line"><span class="type">int</span> b;           <span class="comment">//boolean值</span></span><br><span class="line">&#125;Value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部包括table，string，usedata等定义</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">GCObject</span>&#123;</span></span><br><span class="line">GCheader gch;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">UTString</span> <span class="title">ts</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Udata</span> <span class="title">u</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Closure</span> <span class="title">cl</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Table</span> <span class="title">h</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> <span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UpVal</span> <span class="title">uv</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> <span class="title">th</span>;</span> <span class="comment">/*thread*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下不涉及数据结构表示，只是垃圾回收GC相关定义</span></span><br><span class="line"><span class="comment">//GCheader结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GCheader</span>&#123;</span></span><br><span class="line">CommonHeader;</span><br><span class="line">&#125; GCheader;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CommonHeader定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CommonHeader GCObject *next;lu_byte tt;lu_byte marked</span></span><br><span class="line"><span class="comment">//next:下一个GC链表的成员</span></span><br><span class="line"><span class="comment">//tt：表示数据的类型，即上文图表2.1中的相关类型宏定义</span></span><br><span class="line"><span class="comment">//marked：GC相关标记位</span></span><br></pre></td></tr></table></figure><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled2.png" alt="Untitled.png"></p><p>综上所述，Lua 中的数据结构是基于<strong>TValue</strong>来进行表示的。需要注意的是<strong>Value</strong>中存在的指针*p 是用来存储数据结构 lightusedate（自定义类型），而<strong>GCObject</strong>中的的对象是用来存储 usedate（自定义类型）对象，分别对应上图（数据结构）中的类型 2 与类型 7。这也表示了**<code>usedate会由Lua自动进行回收，但是lightusedate需要程序员自己进行管理</code>**。有上述代码可以得出结论：</p><ul><li>number、boolean、nil、light userdata 四种类型的值是直接存在栈上元素里的，和垃圾回收无关。</li><li>string、table、closure、userdata、thread 等存在栈上元素里的只是指针，数据在堆中他们都会在生命周期结束后被垃圾回收。</li><li>function 类型的存储，通过上述编译原理部分内容以及<strong>GCObject</strong>的 Proto 与 Closure 进行实现</li></ul><h3 id="数据结构：表-Table"><a href="#数据结构：表-Table" class="headerlink" title="数据结构：表 Table"></a>数据结构：表 Table</h3><p>Lua 中的数据结构中，表 Table 是最重要的一种。在逻辑上是一个关联数组（哈希表，实际上是有一个哈希表与数组组成），<code>可以通过任何值（除了 nil）来索引表项，表项可以存储任何类型的值</code>。原因可以看一下存储在<strong>GCObject</strong>中的 struct 表 table 的代码结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">CommonHeader;</span><br><span class="line">lu_byte flags; <span class="comment">//元方法存在标记，标记为1，表示元方法不存在</span></span><br><span class="line">lu_byte lsizenode; <span class="comment">//散列桶数组的大小的 log2(size)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Table</span> <span class="title">netatable</span>;</span> <span class="comment">//元表</span></span><br><span class="line">TValue *<span class="built_in">array</span>; <span class="comment">//指针，指向数组表，数组表中的数据，起始键为1</span></span><br><span class="line">Node *node; <span class="comment">//散列桶起始指针</span></span><br><span class="line">Node *lastfree; <span class="comment">//散列桶末尾指针</span></span><br><span class="line">GCObject *gclist; <span class="comment">//GC相关的链表</span></span><br><span class="line"><span class="type">int</span> sizearray; <span class="comment">//数组表的长度</span></span><br><span class="line">&#125; Table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//table中node所包含的数据与结构（如上图表所示）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">Tkey</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">TValuefield;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;nk;</span><br><span class="line">Tvalue tvk;</span><br><span class="line">&#125;Tkey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">TValue i_val;</span><br><span class="line">Tkey i_key;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled3.png" alt="Untitled"></p><p>有上图以及逻辑代码可以看出：</p><ul><li>Table 的数据存储分为两个部分：所有键值在 1 与 n（上限）之间的数据存储在数组表中，非整数键值或超过键值表示范围的通过散列表进行存储。（这就是 Lua 中迭代器<code>pair与ipair遍历的区别</code>原理）</li><li>数据存储通过 TValue 类型进行存储的。这表示表中可以存放所有的 Lua 数据结构。</li><li>表**<code>netatable</code>**与标记<code>flags</code>实现了元表元方法的相关功能。</li></ul><p>除了以上可以由结构看出的内容之外，有关于表的存储内容相关的部分也需要注意：</p><ul><li>Table 的存储的动态的，也就是数组表与散列表的大小是可以进行动态变化的（动态扩容）。</li><li>最初表的两个部分，都是空的，表的扩容需要 Lua 重新计算散列表与数组表的大小，找到满足一下条件的最大 n 值作为长度：**<code>1到 n 之间至少一半的空间会被利用</code><strong>（避免像稀疏数组一样浪费空间）；</strong><code>并且 n/2+1到 n 之间的空间至少有一个空间被利用</code>**（避免 n/2 个空间就能容纳所有数据时申请 n 个空间而造成浪费）</li><li>Lua 并非在空间上直接增加表大小（结构非链表，不能直接增加节点），而是申请新的空间，并将元数据存放到新空间中。</li><li>表的两个存储部分：数组表与散列表是分开扩容的。这种混合型结构让表在作为数组使用时，有数组的优点（存储紧凑，性能高，键值隐含，不用在意哈希表的空间与计算开销）。作为散列表使用时，数组部分又常常不存在，从而节省内存空间。</li></ul><p>PS：除了以上表述内容之外，Table 数据结构的散列表部分还使用了双重散列技术，又叫双重哈希法，有兴趣可以查找一下相关资料以及 Brent 论文提到的 HashTable 增查新方法 （地址在最后参考文献中）。</p><h3 id="数据结构：字符串-String"><a href="#数据结构：字符串-String" class="headerlink" title="数据结构：字符串 String"></a>数据结构：字符串 String</h3><p>字符串 String 类型与本身是结构体的 table 类似。它本身是 union 联合提结构，底层代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//长短字符串定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TSHRSTR (LUA_TSTRING | (0 &lt;&lt; 4))  <span class="comment">/* short strings */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TLNGSTR (LUA_TSTRING | (1 &lt;&lt; 4))  <span class="comment">/* long strings */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.2版本，区分长短字符串</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte extra;  <span class="comment">/* reserved words for short strings; &quot;has hash&quot; for longs */</span></span><br><span class="line">                  <span class="comment">/* 对于短字符串：这个标示是否是保留字，长字符串：是否已经哈希① */</span></span><br><span class="line">  lu_byte shrlen;  <span class="comment">/* 短字符串的长度 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> hash;<span class="comment">//hash值</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> lnglen;  <span class="comment">/* 长字符串的长度 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> *<span class="title">hnext</span>;</span>  <span class="comment">//哈希表的链表</span></span><br><span class="line">  &#125; u;</span><br><span class="line">&#125; TString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">UTString</span> &#123;</span></span><br><span class="line">  L_Umaxalign dummy;  <span class="comment">/* 内存对齐 */</span></span><br><span class="line">  TString tsv;</span><br><span class="line">&#125; UTString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stringtable</span> &#123;</span></span><br><span class="line">GCObject **hash;</span><br><span class="line">lu_int32 nuse; <span class="comment">/* number of elements */</span></span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line">&#125; stringtable;</span><br></pre></td></tr></table></figure><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled4.png" alt="Untitled"></p><p>在 Lua5.2 之后，字符串存储就被分成了两种：长字符串与短字符串。</p><ul><li>短字符串存储在<code>全局stringtable</code>当中，相同字符串只会有一份实际数据拷贝，每份相同的 TString 对象只是存放一个 hash 值，用来索引 stringtable。</li><li>长字符串直接存储在 union 的<code>hnext</code>当中，相同字符串在内存都是单独一份数据拷贝。</li><li>为了避免链表中数据过多导致的可能的一次线性查找过程，除了长字符串单独存储外，还有 luaS_resize(lua_State *L,int newsize)专门进行重新的散列排列，通常在以下两种情况调用：<ul><li>lgc.c 的 checkSizes 函数：散列桶数量太大（是实际存放的字符串 4 倍），减少为原本一倍</li><li>lstring.c 的 newlstr 函数：字符串数量太大（字符串数量大于桶数量，并且桶数组的数量小于 MAX_INT/2）,对桶进行翻倍扩容</li></ul></li></ul><h3 id="数据结构：thread（叫线程，是协程）"><a href="#数据结构：thread（叫线程，是协程）" class="headerlink" title="数据结构：thread（叫线程，是协程）"></a>数据结构：thread（叫线程，是协程）</h3><p>Lua 5.0 版开始， <code>Lua 实现不对称协程</code>（也称为半不对称协程或不完全协程） 。</p><p>Lua 将所有关于协同程序的函数放置在一个名为“coroutine”的 table 中。</p><ol><li>coroutine.create 创建一个 thread 类型的值表示新的协同程序，返回一个协同程序。</li><li>coroutine.status 检查协同程序的状态（挂起 suspended、运行 running、死亡 dead、正常 normal）。</li><li>coroutine.resume 启动或再次启动一个协同程序，并将其状态由挂起改为运行。</li><li>coroutine.yield 让一个协同程序挂起。</li><li>coroutine.wrap 同样创建一个新的协同程序，返回一个函数。</li></ol><p>Lua 中协程是有栈的，这样我们就可以在多级函数嵌套调用内挂起（暂停执行）一个协程。解释器只是简单地将整个栈放在一边而在另一个栈上继续执行。 一个程序可以任意重启任何挂起的协程。当与栈相关的协程不可用时，垃圾回收器就回收栈空间。</p><hr><h2 id="Lua-虚拟机的跨语言调用"><a href="#Lua-虚拟机的跨语言调用" class="headerlink" title="Lua 虚拟机的跨语言调用"></a>Lua 虚拟机的跨语言调用</h2><p>Lua 提供了一个虚拟栈，这个虚拟栈可以完成 Lua 语言与其他语言之间的数据交换。Lua API 本身提供了一系列接口可以让我们操作这个虚拟栈。</p><p>以下是 C 语言对虚拟栈的操作 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** push functions (C -&gt; stack)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//数据从C语言到虚拟栈中</span></span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushnil)</span> <span class="params">(lua_State *L)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushnumber)</span> <span class="params">(lua_State *L, lua_Number n)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushinteger)</span> <span class="params">(lua_State *L, lua_Integer n)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushlstring)</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> l)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushstring)</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">char</span> *(lua_pushvfstring) (lua_State *L, <span class="type">const</span> <span class="type">char</span> *fmt,</span><br><span class="line">                                                      va_list argp);</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">char</span> *(lua_pushfstring) (lua_State *L, <span class="type">const</span> <span class="type">char</span> *fmt, ...);</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushcclosure)</span> <span class="params">(lua_State *L, lua_CFunction fn, <span class="type">int</span> n)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushboolean)</span> <span class="params">(lua_State *L, <span class="type">int</span> b)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushlightuserdata)</span> <span class="params">(lua_State *L, <span class="type">void</span> *p)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>   <span class="params">(lua_pushthread)</span> <span class="params">(lua_State *L)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据由虚拟栈到C语言中</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** access functions (stack -&gt; C)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LUA_API <span class="title function_">int</span>             <span class="params">(lua_isnumber)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>             <span class="params">(lua_isstring)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>             <span class="params">(lua_iscfunction)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>             <span class="params">(lua_isuserdata)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>             <span class="params">(lua_type)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">char</span>     *(lua_typename) (lua_State *L, <span class="type">int</span> tp);</span><br><span class="line"></span><br><span class="line">LUA_API <span class="title function_">int</span>            <span class="params">(lua_equal)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx1, <span class="type">int</span> idx2)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>            <span class="params">(lua_rawequal)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx1, <span class="type">int</span> idx2)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>            <span class="params">(lua_lessthan)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx1, <span class="type">int</span> idx2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经实测，to* 函数不会出栈</span></span><br><span class="line">LUA_API <span class="title function_">lua_Number</span>      <span class="params">(lua_tonumber)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">lua_Integer</span>     <span class="params">(lua_tointeger)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>             <span class="params">(lua_toboolean)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">char</span>     *(lua_tolstring) (lua_State *L, <span class="type">int</span> idx, <span class="type">size_t</span> *len);</span><br><span class="line">LUA_API <span class="title function_">size_t</span>          <span class="params">(lua_objlen)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">lua_CFunction</span>   <span class="params">(lua_tocfunction)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="type">void</span>           *(lua_touserdata) (lua_State *L, <span class="type">int</span> idx);</span><br><span class="line">LUA_API lua_State      *(lua_tothread) (lua_State *L, <span class="type">int</span> idx);</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">void</span>     *(lua_topointer) (lua_State *L, <span class="type">int</span> idx);</span><br></pre></td></tr></table></figure><p>以下是 Lua 对虚拟栈的操作 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** get functions (Lua -&gt; stack)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//Lua数据入栈</span></span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_gettable)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_getfield)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, <span class="type">const</span> <span class="type">char</span> *k)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_rawget)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_rawgeti)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, <span class="type">int</span> n)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_createtable)</span> <span class="params">(lua_State *L, <span class="type">int</span> narr, <span class="type">int</span> nrec)</span>;</span><br><span class="line">LUA_API <span class="type">void</span> *(lua_newuserdata) (lua_State *L, <span class="type">size_t</span> sz);</span><br><span class="line">LUA_API <span class="title function_">int</span>   <span class="params">(lua_getmetatable)</span> <span class="params">(lua_State *L, <span class="type">int</span> objindex)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_getfenv)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** set functions (stack -&gt; Lua)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//Lua获取栈中数据或修改栈中数据</span></span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_settable)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_setfield)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, <span class="type">const</span> <span class="type">char</span> *k)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_rawset)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_rawseti)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, <span class="type">int</span> n)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>   <span class="params">(lua_setmetatable)</span> <span class="params">(lua_State *L, <span class="type">int</span> obj</span></span><br></pre></td></tr></table></figure><p>除此之外，还有一系列用来控制堆栈的相关函数（栈操作）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** basic stack manipulation</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LUA_API <span class="title function_">int</span>   <span class="params">(lua_gettop)</span> <span class="params">(lua_State *L)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_settop)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_pushvalue)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_remove)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_insert)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">void</span>  <span class="params">(lua_replace)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span>;</span><br><span class="line">LUA_API <span class="title function_">int</span>   <span class="params">(lua_checkstack)</span> <span class="params">(lua_State *L, <span class="type">int</span> sz)</span>;</span><br></pre></td></tr></table></figure><h3 id="C-C-调用-Lua"><a href="#C-C-调用-Lua" class="headerlink" title="C/C++调用 Lua"></a><strong>C/C++调用 Lua</strong></h3><p><strong>C/C++ 获取 Lua 值</strong></p><ol><li>使用 lua_getglobal 来获取值并将其压栈。</li><li>使用 lua_toXXX 将栈中元素取出（此时元素并不会出栈）转成相应的 C/C++ 类型的值。</li></ol><p><strong>C/C++ 调用 Lua 函数</strong></p><ol><li>使用 lua_getglobal 来获取函数并将其压栈。</li><li>如果这个函数有参数的话，就需要依次将函数的参数也压入栈。</li><li>调用 lua_pcall 开始调用函数，调用完成以后，会将返回值压入栈中。</li><li>取返回值，调用完毕。</li></ol><h3 id="Lua-调用-C-C"><a href="#Lua-调用-C-C" class="headerlink" title="Lua 调用 C/C++"></a><strong>Lua 调用 C/C++</strong></h3><p>Lua 可以调用 C/C++ 的函数，步骤为：</p><ol><li><code>将 C 的函数包装成 Lua 环境认可的函数</code>：将被调用的 C/C++ 函数从普通的 C/C++ 函数包装成 Lua_CFunction 格式，并需要在函数中将返回值压入栈中，并返回返回值个数;</li><li><code>将包装好的函数注册到 Lua 环境中</code>：使用宏<code>lua_register</code> 调用<code>lua_pushfunction(L,f)</code> 和<code>lua_setglobal(L,n)</code>，将函数存放在一个全局 table 中。</li><li>像使用普通 Lua 函数那样使用注册函数。</li></ol><p>PS：注意 XLua 或 ToLua 都是对 Lua 虚拟机做了上层封装，方便进行相关接口调用。</p><hr><h2 id="Lua-的闭包（主要通过-upValue-实现）"><a href="#Lua-的闭包（主要通过-upValue-实现）" class="headerlink" title="Lua 的闭包（主要通过 upValue 实现）"></a>Lua 的闭包（主要通过 upValue 实现）</h2><h3 id="Lua-的闭包定义与使用"><a href="#Lua-的闭包定义与使用" class="headerlink" title="Lua 的闭包定义与使用"></a>Lua 的闭包定义与使用</h3><p>闭包：**<em>能够读取其他函数内部变量的函数</em>**。</p><p>常见形式：通过调用含有一个内部函数加上该外部函数持有的外部局部变量（upvalue）的外部函数产生的一个函数实例。（外部函数+外部局部变量+内部函数（闭包函数））。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">local</span> i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>//尾调用</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    c1=test()</span><br><span class="line">    c2=test()<span class="comment">--c1,c2是建立在同一个函数，同一个局部变量的不同实例上面的两个不同的闭包</span></span><br><span class="line">             <span class="comment">--闭包中的upvalue各自独立，调用一次test（）就会产生一个新的闭包</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(c1()) <span class="comment">--&gt;1</span></span><br><span class="line">    <span class="built_in">print</span>(c1()) <span class="comment">--&gt;2//重复调用时每一个调用都会记住上一次调用后的值，就是说i=1了已经</span></span><br><span class="line">    <span class="built_in">print</span>(c2())    <span class="comment">--&gt;1//闭包不同所以upvalue不同</span></span><br><span class="line">    <span class="built_in">print</span>(c2()) <span class="comment">--&gt;2</span></span><br></pre></td></tr></table></figure><p>由上文输出结果可知：闭包中的外部局部变量在每个函数实例中各自独立，两个实例的调用结果不会相互干扰。同时实例中的外部局部变量会被保存。</p><p>PS：由于迭代器需要保存上一次调用的状态与下一次成功调用的状态，可以正好用闭包的机制实现。（迭代器只是一个生成器，本身不带有循环）以下是迭代器的实现。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">　 <span class="function"><span class="keyword">function</span> <span class="title">list_iter</span><span class="params">(t)</span></span></span><br><span class="line">            <span class="keyword">local</span> i=<span class="number">0</span></span><br><span class="line">            <span class="keyword">local</span> n=<span class="built_in">table</span>.<span class="built_in">getn</span>(t)</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">                i=i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i&lt;=n <span class="keyword">then</span> <span class="keyword">return</span> t[i] <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">--使用</span></span><br><span class="line">t=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">90</span>&#125;</span><br><span class="line">iter=list_iter(t)<span class="comment">--调用迭代器产生一个闭包</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">local</span> element=iter()</span><br><span class="line">    <span class="keyword">if</span> element==<span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">       <span class="built_in">print</span>(element)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--泛型for使用：</span></span><br><span class="line">t=&#123;<span class="number">10</span>,<span class="number">0</span>,<span class="number">29</span>&#125;</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> list_iter(t) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--这里的list_iter()工厂函数只会被调用一次产生一个闭包函数，后面的每一次迭代都是用该闭包函数，而不是工厂函数</span></span><br></pre></td></tr></table></figure><h3 id="Lua-闭包的底层实现"><a href="#Lua-闭包的底层实现" class="headerlink" title="Lua 闭包的底层实现"></a>Lua 闭包的底层实现</h3><p>在 Lua 语言运行期间，任何时候只要 Lua 执行一个 function…end 表达式， 它就会创建一个新的闭包。同时每个闭包会包含以下内容：</p><ul><li>一个对<code>函数原型proto</code>的引用</li><li>一个对<code>环境</code>的引用（环境其实是一个表，函数可在该表中索引全局变量）</li><li>一个数组，数组中每个元素都是一个对 <code>upvalue</code> 的引用，可通过该数组来存取外层的局部变量 （upvalue 是 proto 中的一个信息，见上文）</li></ul><p>闭包最主要的特点是能够获取其他函数内部变量。Lua 是通过<code>upvalue 的结构</code>来实现该功能的，对任何外层局部变量的存取都能间接地通过 upvalue 来进行。upvalue 最初指向栈中变量活跃的地方（图 4 左边） 。当离开变量作用域时（超过变量生存期时） ，变量被复制到 upvalue 中（图 4 右边） 。由于对变量的存取是通过 upvalue 里的指针间接进行的，因此复制动作对任何存取此变量的代码来说都是没有影响的。</p><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled5.png" alt="Untitled"></p><p>与内层函数不同的是， 声明该局部变量的函数直接在堆栈中存取它的局部变量。<code>通过为每个变量至少创建一个 upvalue 并按所需情况进行重复利用</code>，保证了未决状态（是否超过生存期）的局部变量（pending vars）能够在闭包间正确地共享。<code>为了保证这种唯一性， Lua 为整个运行栈保存了一个链接着所有正打开着的 upvalue（那些当前正指向栈内局部变量的 upvalue）的链表</code>（图 4 中未决状态的局部变量的链表） 。当 Lua 创建一个新的闭包时，它开始遍历所有的外层局部变量，对于其中的每一个，若在上述 upvalue 链表中找到它，就重用此 upvalue，否则， Lua 将创建一个新的 upvalue 并加入链表中。注意，<code>一般情况下这种遍历过程在探查了少数几个节点后就结束了</code>， 因为对于每个被内层函数用到的外层局部变量来说，该链表至少包含一个与其对应的入口（upvalue） 。一旦某个关闭的 upvalue 不再被任何闭包所引用，那么它的存储空间就立刻被回收。</p><p>一个函数有可能存取其更外层函数而非直接外层函数的局部变量。 这种情况下，有可能当闭包创建时，此局部变量尚不存在。 <code>Lua 使用 flat 闭包</code>来处理这种情况。<code>有了 flat 闭包，无论何时只要函数存取更外层的局部变量，该变量也会进入其直接外层函数的闭包中</code>。这样，当一个函数被实例化时，所有进入其闭包的变量就在直接外层函数的栈或闭包中了。</p><hr><h3 id="Lua-的元表与元方法（面向对象）"><a href="#Lua-的元表与元方法（面向对象）" class="headerlink" title="Lua 的元表与元方法（面向对象）"></a>Lua 的元表与元方法（面向对象）</h3><p>在 Lua table 中我们可以访问对应的 key 来得到 value 值，但是却无法对两个 table 进行操作。因此<code>Lua 提供了元表(Metatable)，允许我们改变table的行为，每个行为关联了对应的元方法</code>。通俗来说，元表就像是一个“操作指南”，里面包含了一系列操作的解决方案，例如<strong>index 方法就是定义了这个表在索引失败的情况下该怎么办，</strong>add 方法就是告诉 table 在相加的时候应该怎么做。这里面的<strong>index，</strong>add 就是元方法。（上文 table 表的结构中可以看见元表与元方法标记）</p><h3 id="面向对象的实现"><a href="#面向对象的实现" class="headerlink" title="面向对象的实现"></a>面向对象的实现</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--基类Account</span></span><br><span class="line">Account = &#123;balance = <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Account:new</span> <span class="params">(o)</span></span></span><br><span class="line">o = o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(o, <span class="built_in">self</span>)//设置元表为自身</span><br><span class="line"><span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span>//设置<span class="built_in">__index</span>元方法为自身</span><br><span class="line"><span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Account:deposit</span> <span class="params">(v)</span></span></span><br><span class="line"><span class="built_in">self</span>.balance = <span class="built_in">self</span>.balance + v</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Account:withdraw</span> <span class="params">(v)</span></span></span><br><span class="line"><span class="keyword">if</span> v &gt; <span class="built_in">self</span>.balance <span class="keyword">then</span> <span class="built_in">error</span><span class="string">&quot;insufficient funds&quot;</span> <span class="keyword">end</span></span><br><span class="line"><span class="built_in">self</span>.balance = <span class="built_in">self</span>.balance - v</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--子类SpecialAccount</span></span><br><span class="line"><span class="comment">--此时代表SpecialAccount是Account的一个实例，即继承了Account所有内容</span></span><br><span class="line">SpecialAccount = Account:new()</span><br><span class="line"></span><br><span class="line"><span class="comment">--SpecialAccount从Account继承了new方法</span></span><br><span class="line"><span class="comment">--new执行时，self指向SpecialAccount</span></span><br><span class="line"><span class="comment">--s的metable，__index是SpecialAccount</span></span><br><span class="line">s = SpecialAccount:new&#123;limit = <span class="number">1000.00</span>&#125;//s继承了SpecialAccount</span><br><span class="line"></span><br><span class="line"><span class="comment">--在s中找不到deposit域，会到SpecialAccount找，然后到Account中找</span></span><br><span class="line">s:deposit(<span class="number">100.00</span>)</span><br><span class="line"><span class="comment">--------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">--根据上面的描述，我们就可以在SpecialAccount中重写Account方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialAccount:withdraw</span> <span class="params">(v)</span></span></span><br><span class="line"><span class="keyword">if</span> v - <span class="built_in">self</span>.balance &gt;= <span class="built_in">self</span>:getLimit() <span class="keyword">then</span></span><br><span class="line"><span class="built_in">error</span><span class="string">&quot;insufficient funds&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">self</span>.balance = <span class="built_in">self</span>.balance - v</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialAccount:getLimit</span> <span class="params">()</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">self</span>.limit <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--调用方法 s:withdraw(200.00)，Lua 不会到 Account 中查找</span></span><br><span class="line"><span class="comment">--因为它第一次就在 SpecialAccount 中发现了新的 withdraw 方法</span></span><br><span class="line"><span class="comment">--由于 s.limit 等于 1000.00（记住我们创建 s 的时候初始化了这个值）</span></span><br><span class="line"><span class="comment">--程序执行了取款操作，s 的 balance 变成了负值</span></span><br><span class="line">s:withdraw(<span class="number">200.00</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="Lua-语言的-GC-算法"><a href="#Lua-语言的-GC-算法" class="headerlink" title="Lua 语言的 GC 算法"></a>Lua 语言的 GC 算法</h2><h3 id="两种常见的垃圾回收算法"><a href="#两种常见的垃圾回收算法" class="headerlink" title="两种常见的垃圾回收算法"></a>两种常见的垃圾回收算法</h3><ul><li><strong>自动引用计数(Automatic Reference Counting)算法</strong>（****ARC 算法****）<ul><li>对每一个对象保存一个整形的引用计数属性，用来记录对象被引用的情况，当记录对象被引用数维 0 时，将会被 GC 进行回收。</li><li>实现简单，判定效率高，回收没有延迟</li><li>单独的存储计数器字段，增加了存储空间的开销；每次赋值需要更新存储计数器增加了时间开销；<strong>无法处理循环引用问题</strong>（致命）</li><li>解决方法（Java）：可达性分析（不可达对象不等于无引用对象，最少要分析标记两次）<br><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled6.png" alt="Untitled"></li></ul></li><li>*<strong>*标记-清除（Mark - Sweep）算法**</strong><ul><li>当堆中的有效内存空间被耗尽时，停止整个程序，进行标记工作与清除工作<ul><li>标记：Collector从根节点开始遍历，标记所有被引用对象。（一般在对象的 Header 中记录为可达对象）</li><li>清除：Collector对堆内存进行从头到尾的线性遍历，发现没有标记为可达对象的对象将其回收</li></ul></li><li>效率低，GC 时需要停止整个用户进程，用户体验差，清理出的内存不连续没需要维护一个空闲链表</li></ul></li></ul><h3 id="Lua-的-GC-原理与算法设计"><a href="#Lua-的-GC-原理与算法设计" class="headerlink" title="Lua 的 GC 原理与算法设计"></a>Lua 的 GC 原理与算法设计</h3><ul><li>Lua 语言的 GC 算法采用<code>标记-清除（Mark - Sweep）算法</code></li><li>在 Lua5.1 之前，Lua 的 GC 过程是一次性不可打断的过程，采用的 Mark 算法是双色标记算法，黑色不被回收，白色被回收。但是如果在 GC 过程的回收阶段中，加入新的对象，不论标记成什么颜色都不对，所以在后来被改进</li><li>Lua5.1 之后采用了分布回收（增量 GC 的实现）以及<code>三色增量标记清除算法</code><br>更新之后的节点主要分为三种：<ul><li><strong>黑色节点</strong>：已经完全扫描过的节点。</li><li><strong>灰色节点</strong>：在扫描黑色节点时候初步扫描到，但是还未完全扫描的 obj，这类 obj 会被放到一个待处理列表中进行逐个完全扫描。</li><li><strong>白色节点</strong>：还未被任何黑色节点所引用的节点(因为一旦被黑色节点引用将被置为黑色或灰色)。这里白色又被进一步细分为<strong>cur white</strong>和<strong>old white</strong>，lua 会记录当前的<strong>cur white</strong>颜色，每个节点新创建的时候都是<strong>cur white</strong>，lua 会在 mark 阶段结束的时候翻转这个<strong>cur white</strong>的位，从而使得这之前创建的白色节点都是<strong>old</strong>的，在 sweep 阶段能够得到正确释放。</li></ul></li></ul><p>GC 的主要流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">为每一个新创建的节点设置为cur white（当前白色）</span><br><span class="line"><span class="comment">//初始化阶段</span></span><br><span class="line">遍历root根节点的引用对象，将white（所有白色）设置成灰色，放入灰色节点链表中</span><br><span class="line"><span class="comment">//标记阶段（存在引用屏障，保证黑色节点不指向白色节点，灰色是屏障）</span></span><br><span class="line">循环扫描灰色链表中的元素，将其置为黑色，然后扫描与该元素关联的其他元素，白色置灰加入灰色节点链表</span><br><span class="line">结束回收阶段，将所有cur white的节点设置成old white的节点（保证这些节点都是要被回收的，回收阶段新加入的白色节点不回收）</span><br><span class="line"><span class="comment">//回收阶段</span></span><br><span class="line">（可能存在新的白色节点加入，设置为cur white）</span><br><span class="line">遍历所有对象，回收所有old white节点</span><br></pre></td></tr></table></figure><hr><p>2023年9月27日补充说明：</p><p>由于白色节点分为cur white与old white两种，任何新加入的白色节点都是cur white。只有在标记阶段最后才会将还存在的cur white修改为old white。由于Lua5.1之后采用的分布回收的GC算法，导致在GC的任何过程中都有可能存在新的内存申请，导致产生新的白色节点并且是cur white类型。如果是在回收阶段，可以不做理会，因为回收阶段只会回收所有old white类型的白色节点，但是如果是在标记阶段，则有可能存在新加入的白色节点处在已经遍历过的位置（黑色节点的父对象或子对象→没有加入灰色链表），从而不会被遍历，使得新加入的节点cur white在标记阶段结束时被修改为old white类型，导致新申请的内存被回收。</p><p>为了处理以上的这个问题，Lua主要采用了2种barrier机制，避免新申请的白色节点被错误释放：</p><ol><li><strong>前向barrier</strong>：将被黑色节点引用的白色节点置为黑色或灰色，例如，当表table（黑）新增元表metatable（白）时，会立即将元表置灰</li><li><strong>反向barrier</strong>：将引用白色节点的黑色节点重新置为灰色，例如，当表table（黑）新增一对键值key_value（白）时，立即将表table置灰</li></ol><hr><h2 id="Lua-语言的基础写法"><a href="#Lua-语言的基础写法" class="headerlink" title="Lua 语言的基础写法"></a>Lua 语言的基础写法</h2><p>指路：<a href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程 | 菜鸟教程 (runoob.com)</a></p><hr><h2 id="参考文献与学习资料"><a href="#参考文献与学习资料" class="headerlink" title="参考文献与学习资料"></a>参考文献与学习资料</h2><ul><li><a href="https://blog.csdn.net/yuanlin2008/article/details/8486463">探索 Lua5.2 内部实现:编译系统(1) 概述_yuanlin2008 的博客-CSDN 博客</a></li><li><a href="https://www.lfzxb.top/the-theory-of-lua-5-0/">Lua5.0 原理探究 | 登峰造极者，殊途亦同归。 (lfzxb.top)</a></li><li><a href="https://www.codingnow.com/2000/download/The%20Implementation%20of%20Lua5.0.pdf">The Implementation of Lua5.0.pdf (codingnow.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/454695276?utm_id=0">Lua 跨语言调用 - 知乎 (zhihu.com)</a></li><li>Brent 论文提到的 HashTable 增查新方法 地址：<a href="https://maths-people.anu.edu.au/~brent/pd/rpb013.pdf">https://maths-people.anu.edu.au/~brent/pd/rpb013.pdf</a></li><li><a href="https://www.cnblogs.com/Jaysonhome/category/1557006.html">Lua 相关 - 随笔分类 - 天山鸟 - 博客园 (cnblogs.com)</a></li><li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/v_xchen_v/article/details/77249332">https://link.zhihu.com/?target=https%3A//blog.csdn.net/v_xchen_v/article/details/77249332</a></li><li>《Lua 的设计与实现》</li><li>《Lua5.3 王桂林》</li></ul>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity渲染顺序探究</title>
      <link href="/2023/09/05/Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/"/>
      <url>/2023/09/05/Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>2023年10月7日更新</p><hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间在群里看见一个有关于求问Unity渲染透明物体与不透明物体渲染顺序的问题，有群友提到了深度与渲染顺序有关，就去找了相关资料学习，并在这里记录一下。</p><h3 id="Unity的UGUI层级渲染顺序管理"><a href="#Unity的UGUI层级渲染顺序管理" class="headerlink" title="Unity的UGUI层级渲染顺序管理"></a>Unity的UGUI层级渲染顺序管理</h3><p>主要是层级管理可以看下方这一张图片，其中RenderQueue的数值关系到了渲染队列的划分。unity中的渲染队列主要有5个，分别是背景渲染队列，不透明渲染队列，透明度测试渲染队列，透明度混合渲染队列以及特殊物体渲染队列（主要用来渲染同一个物体存在相互遮挡且透明的情况）。其中最主要的不透明与透明渲染队列的划分也就如下图所示，是以2500为分界线。</p><p><img src="../Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/Untitled.png" alt="Untitled"></p><p>摄像机的Depth：值越大，渲染物体越靠上，<strong>摄像机会根据Depth从小到大的顺序，渲染各自Culling Mask的层。</strong></p><p>RenderQueue：渲染物体的透明度，小于2500的先渲染</p><p>SortingLayer：SortingLayer在Inspector面板中点击Tag -&gt; AddTag -&gt; SortingLayer，可以添加自定义的sortingLayer，默认的sortingLayer为Default</p><p>Order In Layer：SortingLayer中的内部渲染排序。</p><p><img src="../Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/Untitled1.png" alt="Untitled"></p><p><img src="../Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/Untitled2.png" alt="Untitled"></p><p>RectTransform.SetSiblingIndex：设置显示与渲染顺序，值越大，越靠上</p><ul><li>SetAsFirstSibling：移动到所有兄弟节点的第一个位置（Hierarchy同级最上面，先渲染，显示在最下面）</li><li>SetAsLastSibling：移动到所有兄弟节点的最后一个位置（Hierarchy同级最下面，后渲染，显示在最上面）</li><li>GetSiblingIndex：获得该元素在当前兄弟节点层级的位置</li><li>SetSiblingIndex：设置该元素在当前兄弟节点层级的位置</li></ul><p>除此之外还有根据深度z轴判断前后关系，y轴判断前后关系，x轴判断前后关系等，在2.5D游戏中人物与环境的遮挡交互会使用到，这里先不做过多的赘述。</p><h3 id="Unity的渲染队列（2023年10月7日更新）"><a href="#Unity的渲染队列（2023年10月7日更新）" class="headerlink" title="Unity的渲染队列（2023年10月7日更新）"></a>Unity的渲染队列（2023年10月7日更新）</h3><p>Unity通过渲染队列来进行如下。在unityShader中的SubShader的**<code>Queue</code>**标签可以决定模型改归于哪一个渲染队列，索引号越小表示越早被渲染。渲染队列有以下几种：</p><table><thead><tr><th>名称</th><th>队列索引号</th><th>描述</th></tr></thead><tbody><tr><td>Background</td><td>1000</td><td>该队列在其他所有队列之前被渲染，通常用来渲染需要被绘制在背景上的物体</td></tr><tr><td>Geometry</td><td>2000</td><td>默认渲染队列，大多数物体使用的队列，不透明物体使用的队列</td></tr><tr><td>AlphaTest</td><td>2450（小于2500为完全不透明）</td><td>需要进行透明度测试的物体使用的队列。</td></tr><tr><td>Transparent</td><td>3000</td><td>该队列中的物体会在前两个队列（Geometry与AlphaTest）渲染之后，再根据从后往前的顺序进行渲染，所有使用了透明度混合的物体使用该队列。</td></tr><tr><td>Overlay</td><td>4000</td><td>该队列用来实现叠加效果，任何需要在最后渲染的物体使用这个队列</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
            <tag> Unity </tag>
            
            <tag> 图形渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A*算法</title>
      <link href="/2023/08/06/A-%E7%AE%97%E6%B3%95/"/>
      <url>/2023/08/06/A-%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一种在静态路网中求解最短路径最有效的直接搜索算法。</p><hr><h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><p>F=G+H（f*(n)=g*(n)+h*(n)）</p><p>G：代表从起点A移动到指定方格的移动代价（路径长短）</p><p>H：代表从指定方格移动到终点B的移动代价（路径长短）</p><hr><h3 id="G点的计算"><a href="#G点的计算" class="headerlink" title="G点的计算"></a>G点的计算</h3><p>PS：需要使用到开放列表中父节点的应用</p><ul><li>假设角色横向与纵向的移动代价是10，对角线的移动代价是14（平方根）,。计算G值的方法就是找到父节点的G值，再根据横纵向，还是对角线为G值加上10或14。</li></ul><h3 id="H值的估算-Manhattan-方法：试探法"><a href="#H值的估算-Manhattan-方法：试探法" class="headerlink" title="H值的估算(Manhattan 方法：试探法)"></a>H值的估算(Manhattan 方法：试探法)</h3><p>PS：方法有很多不同的，可上网查找。</p><ul><li>计算从当前方格横向或纵向移动到达目标所经过的方格数，忽略对角移动，然后把总数乘以 10。</li></ul><h3 id="openlist（开放列表）与closelist（封闭列表）"><a href="#openlist（开放列表）与closelist（封闭列表）" class="headerlink" title="openlist（开放列表）与closelist（封闭列表）"></a>openlist（开放列表）与closelist（封闭列表）</h3><ul><li>openlist：记录所有被考虑来寻找最短路径的网格集合（经过路径的所有相邻节点逐渐加入该列表）</li><li>closelist：一个记录下不会被考虑的网格集合（已经被选中的路径点加入该列表）</li></ul><hr><p><img src="../A-%E7%AE%97%E6%B3%95/Untitled.png" alt="Untitled"></p><h3 id="寻路步骤："><a href="#寻路步骤：" class="headerlink" title="寻路步骤："></a>寻路步骤：</h3><ul><li>简化搜索区域，将搜索区域简化成2维数组，数组中每一项代表一个格子。状态分成可走与不可走。</li><li>从起点A开始，将其加入方格组成的openlist（开放列表）中，列表中的格子是路径可能会沿途经过的（有可能经过的方块格）。  <img src="../A-%E7%AE%97%E6%B3%95/Untitled1.png" alt="Untitled"></li><li>查找与A相邻的方格（忽略障碍物所在的格子），将所有可达的方格加入到openlist列表当中，并且将起点A设置成这些可达方格的父节点。</li><li>将方格A从openlist列表中移除，加入到closelist（封闭列表）当中。</li><li>根据公式计算，取出openlist表中F值最小的方格数据，放入closelist中。</li><li>检索该方格相邻的所有方格，忽略不可达以及在closelist中的方格，openlist中，并为加入的方格设置父节点。重复以上操作。</li><li>如果发现相邻的方格已经存在了openlist当中，就检查这条路径是否更优（是否具有更小的G值），没有则不作操作。如果 G 值更小，则把那个方格的父亲设为当前方格 ( 我们选中的方格 )，然后重新计算那个方格的 F 值和 G 值</li></ul><hr><h3 id="算法性能的提高"><a href="#算法性能的提高" class="headerlink" title="算法性能的提高"></a>算法性能的提高</h3><ul><li>可以再openlist表中保存好路径元素，并且对表中元素进行排序，这样每次取值只要取第一个方格的数据就行</li><li>使用二叉堆（快2~3倍）：<a href="http://www.policyalmanac.org/games/binaryHeaps.htm">Using Binary Heaps in A* Pathfinding</a></li><li>系列点子<ul><li>使用小地图或者更少的寻路者</li><li>千万不要同时给多个寻路者寻路。取而代之的是把它们放入队列中，分散到几个游戏周期中。</li><li>考虑在地图中使用更大的方格。这减少了寻路时需要搜索的方格数量。或长路径使用大方块，接近目标使用小方块。资料：<a href="http://www.policyalmanac.org/games/twoTiered.htm">Two-Tiered A* Pathfinding</a></li><li>对于很长的路径，考虑使用路径点系统，或者可以预先计算路径并加入游戏中。</li><li>预先处理你的地图，指出哪些区域是不可到达的。这些区域称为“孤岛”。A* 的下限是，你告诉他搜寻通往哪些区域的路径时，他会搜索整个地图，直到所有可以抵达的方格都通过 open list 或 close list 得到了处理。</li><li>不同的地形损耗，地形不是只有 2 种：可抵达的和不可抵达，不同的地形移动代价可以不同，沼泽，山丘，地牢的楼梯等等</li><li>influence Mapping：创建一个额外的计分系统，把它应用到寻路的 AI 中。地图上有个通道穿过山丘，有大批的寻路者要通过这个通道，电脑每次产生一个通过那个方格的路径都会变得很拥挤。如果需要，你可以产生一个 influence map，用来标记提高那些方格的移动代价，让电脑避开那个区域移动</li><li>采用布兰森汉姆算法预先判断两点是否可以直接通行,可通行就直接返回两点的直线路径,不可直接通行再采用A星算法寻路</li><li>A*算法走的是最小代价路径，但不一定是最平滑的路径。可以增加一个额外开销，作为允许G值的一定波动范围，然后查找相邻格子中最平滑的地方。</li></ul><hr>  github简单实例链接（没做优化版）：<a href="https://github.com/The-Black-Sun/Static_pathfinding_algorithm_A_Star">https://github.com/The-Black-Sun/Static_pathfinding_algorithm_A_Star</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 路径规划 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
