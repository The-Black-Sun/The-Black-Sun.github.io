<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Lua学习总结</title>
      <link href="/2023/09/06/Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2023/09/06/Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作一直在写Lua相关的游戏逻辑脚本，但一直没做个总结，前端时间看了一下Lua语言的底层逻辑，做个记录总结让以后可以拿出来翻翻看。文章有点长，可以通过索引查找对应内容。</p><hr><h2 id="Lua的底层与编译"><a href="#Lua的底层与编译" class="headerlink" title="Lua的底层与编译"></a>Lua的底层与编译</h2><h3 id="语言类型与区别"><a href="#语言类型与区别" class="headerlink" title="语言类型与区别"></a>语言类型与区别</h3><p>Lua语言是以C语言为底层的<code>脚本语言</code>（动态语言，运行时编译），与C语言，C++等<code>静态语言</code>（静态语言，运行前编译）不同。其中Lua的执行主要运行流程如下：</p><ul><li>程序员编辑Lua脚本代码，保存.lua文件</li><li>语法词法分析，并生成指令集（*lua.byte文件），属于编译过程</li><li>Lua虚拟机执行指令集，属于执行过程</li><li>输出结果</li></ul><p>这里放一张由大佬（<strong>烟雨迷离半世殇</strong>）做的对比表格：</p><table><thead><tr><th>语言</th><th>编辑</th><th>预编译</th><th>运行时编译</th><th>执行</th></tr></thead><tbody><tr><td>Lua</td><td>编写lua文件</td><td>无</td><td>虚拟机读取字节码并转换成虚拟机指令，汇编器编译成机器码</td><td>CPU执行机器码</td></tr><tr><td>C#</td><td>编写cs文件</td><td>被C#编译器编译成dll，包含IL代码</td><td>CLR使用JIT编译把IL转换成机器码</td><td>CPU执行机器码</td></tr></tbody></table><h3 id="Lua语言编译原理"><a href="#Lua语言编译原理" class="headerlink" title="Lua语言编译原理"></a>Lua语言编译原理</h3><p>Lua语言的的编译，首先需要明白代码块（chunk），闭包（closure），和原型（proto）的关系。</p><ol><li>chunk：代码块，一段符合Lua语法的代码。</li><li>closure：Lua运行期间的一个实例对象，在运行期间调用的大多是一个closure。</li><li>proto：（原型）Lua语言中closure的原型（类似与C++中对象声明与实例的关系），定义了有关代码段的大部分信息，包括：<ul><li>指令列表：包含了函数编译后生成的<code>虚拟机指令</code>。</li><li>常量表：这个函数运行期需要的<code>所有常量</code>，在指令中，常量使用常量表id进行索引。</li><li>子proto表：所有内嵌于这个函数的<code>proto列表</code>，在OP_CLOSURE指令中的proto id就是索引的这个表。</li><li>局部变量描述：这个函数使用到的<code>所有局部变量名称，以及生命期</code>。由于<code>所有的局部变量运行期都被转化成了寄存器id</code>，所以这些信息只是debug使用。</li><li>Upvalue描述：upvalue是内嵌函数中能够访问到的外包函数中的局部变量；称为外部局部变量感觉更为贴切。在创建closure时（创建函数实例）初始化Upvalue。</li></ul></li></ol><p>每一个proto在运行期间可以产生多个closure对象来表示函数实例。</p><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled.png" alt="Untitled"></p><p>**<code>closure是运行期的对象</code>**，与运行期关系更大；而<code>与编译期相关的其实是proto对象</code>，他才是编译过程真正需要生成的目标对象。</p><h3 id="Lua语言编译流程"><a href="#Lua语言编译流程" class="headerlink" title="Lua语言编译流程"></a>Lua语言编译流程</h3><ul><li>首先调用<code>lua_load</code> api，将一块符合lua语法的代码块<code>Chunk</code>进行编译。</li><li>编译为当前的Chunk生成一个<code>mainfunc proto</code>对象，并生成一个父对象<code>mainfunc closure</code>对象放到当前的栈顶中，等待接下来的执行。</li><li>Chunk内部的每个<code>function statement（函数语句）</code>也都会生成一个对应的<code>子proto</code>，保存在外层函数的子函数列表中（proto中有子proto列表）。</li><li>所有最外层的**<code>function statement</code>**的proto会被保存到<code>mainfunc proto</code>的子函数列表中。</li><li>按照层次依次编译，形成一个以<code>mainfunc</code>为根节点的proto树。</li></ul><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled1.png" alt="Untitled"></p><hr><h2 id="Lua的底层数据结构"><a href="#Lua的底层数据结构" class="headerlink" title="Lua的底层数据结构"></a>Lua的底层数据结构</h2><p>只要讲到有关于Lua与其他语言交互的过程的相关原理，虚拟机一定是一个不可能绕过的概念。需要注意的是不同于像**<code>C#，java等语言使用的是基于堆栈的虚拟机</code><strong>，Lua5.0之后，<code>**Lua语言开始改用基于寄存器的虚拟机</code>。</strong>首先了解一下，Lua底层数据结构的实现方式。</p><h3 id="C语言的实现面向对象（注意可能存在Lua版本差异）"><a href="#C语言的实现面向对象（注意可能存在Lua版本差异）" class="headerlink" title="C语言的实现面向对象（注意可能存在Lua版本差异）"></a>C语言的实现面向对象（注意可能存在Lua版本差异）</h3><p>由于Lua的底层是通过C语言进行实现的，所以在设置Lua的数据结构的时候，也是通过C语言来进行实现。而主要的实现思路是：</p><ul><li>定义一个公共的数据结构作为基础类型，用来存储表达数据的基础信息，其他类型由此派生（<strong>需要注意的是这个基础类型需要包含所有数据的存储方式，通过Union进行实现</strong>）。</li><li>使用联合（ union ）来将所有数据包进来，<ul><li><strong>Value</strong>提供基础数据的存储方式（GC对象，指针，number与布朗值）以及<strong>GCObject</strong>。</li><li><strong>GCObject</strong>提供所有非基础类型的存储方式（table，string，closure等），需要进行垃圾回收</li></ul></li></ul><pre class="language-c" data-language="c"><code class="language-c">struct lua_TValue &#123;  Value value_;   int tt_;         &#x2F;&#x2F;数据类型标识，新版11种（下截图），同时使用TValuefields进行表示&#125; TValue;typedef union &#123;GCObject *gc;    &#x2F;&#x2F;上述所有需要进行数据回收的联合体，指针，指向联合体GCObject定义（table，thread，closure等）void *p;         &#x2F;&#x2F;轻量级light，userdata，指针lua_CFunction f; &#x2F;&#x2F;旧版没有这个。C语言函数lua_Integer i;   &#x2F;&#x2F;整形类型，Lua5.1版本中只使用了lua_Number来进行整数和浮点数表示，但范围比int64_t类型小，之后Lua5.3扩充了整形类型来表示整数lua_Number n;    &#x2F;&#x2F;默认为double类型，Lua重编译可更换int b;           &#x2F;&#x2F;boolean值&#125;Value;&#x2F;&#x2F;内部包括table，string，usedata等定义union GCObject&#123;GCheader gch;union UTString ts;union Udata u;union Closure cl;struct Table h;struct Proto p;struct UpVal uv;struct lua_State th; &#x2F;*thread*&#x2F;&#125;&#x2F;&#x2F;以下不涉及数据结构表示，只是垃圾回收GC相关定义&#x2F;&#x2F;GCheader结构体typedef struct GCheader&#123;CommonHeader;&#125; GCheader;&#x2F;&#x2F;CommonHeader定义#define CommonHeader GCObject *next;lu_byte tt;lu_byte marked&#x2F;&#x2F;next:下一个GC链表的成员&#x2F;&#x2F;tt：表示数据的类型，即上文图表2.1中的相关类型宏定义&#x2F;&#x2F;marked：GC相关标记位</code></pre><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled2.png" alt="Untitled.png"></p><p>综上所述，Lua中的数据结构是基于<strong>TValue</strong>来进行表示的。需要注意的是<strong>Value</strong>中存在的指针<em>p是用来存储数据结构lightusedate（自定义类型），而<strong>GCObject</strong>中的的对象是用来存储usedate（自定义类型）对象，分别对应上图（数据结构）中的类型2与类型7。这也表示了*</em><code>usedate会由Lua自动进行回收，但是lightusedate需要程序员自己进行管理</code>**。有上述代码可以得出结论：</p><ul><li>number、boolean、nil、light userdata 四种类型的值是直接存在栈上元素里的，和垃圾回收无关。</li><li>string、table、closure、userdata、thread等存在栈上元素里的只是指针，数据在堆中他们都会在生命周期结束后被垃圾回收。</li><li>function类型的存储，通过上述编译原理部分内容以及<strong>GCObject</strong>的Proto 与Closure进行实现</li></ul><h3 id="数据结构：表Table"><a href="#数据结构：表Table" class="headerlink" title="数据结构：表Table"></a>数据结构：表Table</h3><p>Lua中的数据结构中，表Table是最重要的一种。在逻辑上是一个关联数组（哈希表，实际上是有一个哈希表与数组组成），<code>可以通过任何值（除了 nil）来索引表项，表项可以存储任何类型的值</code>。原因可以看一下存储在<strong>GCObject</strong>中的struct表table的代码结构：</p><pre class="language-c" data-language="c"><code class="language-c">typedef struct Table &#123; CommonHeader; lu_byte flags; &#x2F;&#x2F;元方法存在标记，标记为1，表示元方法不存在lu_byte lsizenode; &#x2F;&#x2F;散列桶数组的大小的 log2(size)struct Table netatable; &#x2F;&#x2F;元表TValue *array; &#x2F;&#x2F;指针，指向数组表，数组表中的数据，起始键为1Node *node; &#x2F;&#x2F;散列桶起始指针Node *lastfree; &#x2F;&#x2F;散列桶末尾指针GCObject *gclist; &#x2F;&#x2F;GC相关的链表int sizearray; &#x2F;&#x2F;数组表的长度&#125; Table;&#x2F;&#x2F;table中node所包含的数据与结构（如上图表所示）typedef union Tkey&#123;struct &#123;TValuefield;struct Node *next; &#125;nk;Tvalue tvk;&#125;Tkey;typedef struct Node&#123;TValue i_val;Tkey i_key;&#125;Node;</code></pre><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled3.png" alt="Untitled"></p><p>有上图以及逻辑代码可以看出：</p><ul><li>Table的数据存储分为两个部分：所有键值在1与n（上限）之间的数据存储在数组表中，非整数键值或超过键值表示范围的通过散列表进行存储。（这就是Lua中迭代器<code>pair与ipair遍历的区别</code>原理）</li><li>数据存储通过TValue类型进行存储的。这表示表中可以存放所有的Lua数据结构。</li><li>表**<code>netatable</code>**与标记<code>flags</code>实现了元表元方法的相关功能。</li></ul><p>除了以上可以由结构看出的内容之外，有关于表的存储内容相关的部分也需要注意：</p><ul><li>Table的存储的动态的，也就是数组表与散列表的大小是可以进行动态变化的（动态扩容）。</li><li>最初表的两个部分，都是空的，表的扩容需要Lua重新计算散列表与数组表的大小，找到满足一下条件的最大n值作为长度：**<code>1到 n 之间至少一半的空间会被利用</code><strong>（避免像稀疏数组一样浪费空间）；</strong><code>并且 n/2+1到 n 之间的空间至少有一个空间被利用</code>**（避免 n/2 个空间就能容纳所有数据时申请 n 个空间而造成浪费）</li><li>Lua并非在空间上直接增加表大小（结构非链表，不能直接增加节点），而是申请新的空间，并将元数据存放到新空间中。</li><li>表的两个存储部分：数组表与散列表是分开扩容的。这种混合型结构让表在作为数组使用时，有数组的优点（存储紧凑，性能高，键值隐含，不用在意哈希表的空间与计算开销）。作为散列表使用时，数组部分又常常不存在，从而节省内存空间。</li></ul><p>PS：除了以上表述内容之外，Table数据结构的散列表部分还使用了双重散列技术，又叫双重哈希法，有兴趣可以查找一下相关资料以及Brent论文提到的HashTable增查新方法 （地址在最后参考文献中）。</p><h3 id="数据结构：字符串String"><a href="#数据结构：字符串String" class="headerlink" title="数据结构：字符串String"></a>数据结构：字符串String</h3><p>字符串String类型与本身是结构体的table类似。它本身是union联合提结构，底层代码如下：</p><pre class="language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;长短字符串定义#define LUA_TSHRSTR (LUA_TSTRING | (0 &lt;&lt; 4))  &#x2F;* short strings *&#x2F;#define LUA_TLNGSTR (LUA_TSTRING | (1 &lt;&lt; 4))  &#x2F;* long strings *&#x2F;&#x2F;&#x2F;5.2版本，区分长短字符串typedef struct TString &#123;  CommonHeader;  lu_byte extra;  &#x2F;* reserved words for short strings; &quot;has hash&quot; for longs *&#x2F;                  &#x2F;* 对于短字符串：这个标示是否是保留字，长字符串：是否已经哈希① *&#x2F;  lu_byte shrlen;  &#x2F;* 短字符串的长度 *&#x2F;  unsigned int hash;&#x2F;&#x2F;hash值  union &#123;    size_t lnglen;  &#x2F;* 长字符串的长度 *&#x2F;    struct TString *hnext;  &#x2F;&#x2F;哈希表的链表  &#125; u;&#125; TString;typedef union UTString &#123;  L_Umaxalign dummy;  &#x2F;* 内存对齐 *&#x2F;  TString tsv;&#125; UTString;typedef struct stringtable &#123; GCObject **hash; lu_int32 nuse; &#x2F;* number of elements *&#x2F; int size; &#125; stringtable;</code></pre><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled4.png" alt="Untitled"></p><p>在Lua5.2之后，字符串存储就被分成了两种：长字符串与短字符串。</p><ul><li>短字符串存储在<code>全局stringtable</code>当中，相同字符串只会有一份实际数据拷贝，每份相同的TString对象只是存放一个hash值，用来索引stringtable。</li><li>长字符串直接存储在union的<code>hnext</code>当中，相同字符串在内存都是单独一份数据拷贝。</li><li>为了避免链表中数据过多导致的可能的一次线性查找过程，除了长字符串单独存储外，还有luaS_resize(lua_State *L,int newsize)专门进行重新的散列排列，通常在以下两种情况调用：<ul><li>lgc.c的checkSizes函数：散列桶数量太大（是实际存放的字符串4倍），减少为原本一倍</li><li>lstring.c的newlstr函数：字符串数量太大（字符串数量大于桶数量，并且桶数组的数量小于MAX_INT/2）,对桶进行翻倍扩容</li></ul></li></ul><h3 id="数据结构：thread（叫线程，是协程）"><a href="#数据结构：thread（叫线程，是协程）" class="headerlink" title="数据结构：thread（叫线程，是协程）"></a>数据结构：thread（叫线程，是协程）</h3><p>Lua 5.0 版开始， <code>Lua 实现不对称协程</code>（也称为半不对称协程或不完全协程） 。</p><p>Lua将所有关于协同程序的函数放置在一个名为“coroutine”的table中。</p><ol><li>coroutine.create创建一个thread类型的值表示新的协同程序，返回一个协同程序。</li><li>coroutine.status检查协同程序的状态（挂起suspended、运行running、死亡dead、正常normal）。</li><li>coroutine.resume启动或再次启动一个协同程序，并将其状态由挂起改为运行。</li><li>coroutine.yield让一个协同程序挂起。</li><li>coroutine.wrap同样创建一个新的协同程序，返回一个函数。</li></ol><p>Lua 中协程是有栈的，这样我们就可以在多级函数嵌套调用内挂起（暂停执行）一个协程。解释器只是简单地将整个栈放在一边而在另一个栈上继续执行。 一个程序可以任意重启任何挂起的协程。当与栈相关的协程不可用时，垃圾回收器就回收栈空间。</p><hr><h2 id="Lua虚拟机的跨语言调用"><a href="#Lua虚拟机的跨语言调用" class="headerlink" title="Lua虚拟机的跨语言调用"></a>Lua虚拟机的跨语言调用</h2><p>Lua提供了一个虚拟栈，这个虚拟栈可以完成Lua语言与其他语言之间的数据交换。Lua API本身提供了一系列接口可以让我们操作这个虚拟栈。</p><p>以下是C语言对虚拟栈的操作API：</p><pre class="language-c" data-language="c"><code class="language-c">&#x2F;*** push functions (C -&gt; stack)*&#x2F;&#x2F;&#x2F;数据从C语言到虚拟栈中LUA_API void  (lua_pushnil) (lua_State *L);LUA_API void  (lua_pushnumber) (lua_State *L, lua_Number n);LUA_API void  (lua_pushinteger) (lua_State *L, lua_Integer n);LUA_API void  (lua_pushlstring) (lua_State *L, const char *s, size_t l);LUA_API void  (lua_pushstring) (lua_State *L, const char *s);LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,                                                      va_list argp);LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);LUA_API void  (lua_pushboolean) (lua_State *L, int b);LUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);LUA_API int   (lua_pushthread) (lua_State *L);&#x2F;&#x2F;数据由虚拟栈到C语言中&#x2F;*** access functions (stack -&gt; C)*&#x2F;LUA_API int             (lua_isnumber) (lua_State *L, int idx);LUA_API int             (lua_isstring) (lua_State *L, int idx);LUA_API int             (lua_iscfunction) (lua_State *L, int idx);LUA_API int             (lua_isuserdata) (lua_State *L, int idx);LUA_API int             (lua_type) (lua_State *L, int idx);LUA_API const char     *(lua_typename) (lua_State *L, int tp);LUA_API int            (lua_equal) (lua_State *L, int idx1, int idx2);LUA_API int            (lua_rawequal) (lua_State *L, int idx1, int idx2);LUA_API int            (lua_lessthan) (lua_State *L, int idx1, int idx2);&#x2F;&#x2F; 经实测，to* 函数不会出栈LUA_API lua_Number      (lua_tonumber) (lua_State *L, int idx);LUA_API lua_Integer     (lua_tointeger) (lua_State *L, int idx);LUA_API int             (lua_toboolean) (lua_State *L, int idx);LUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);LUA_API size_t          (lua_objlen) (lua_State *L, int idx);LUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);LUA_API void           *(lua_touserdata) (lua_State *L, int idx);LUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);LUA_API const void     *(lua_topointer) (lua_State *L, int idx);</code></pre><p>以下是Lua对虚拟栈的操作API：</p><pre class="language-c" data-language="c"><code class="language-c">&#x2F;*** get functions (Lua -&gt; stack)*&#x2F;&#x2F;&#x2F;Lua数据入栈LUA_API void  (lua_gettable) (lua_State *L, int idx);LUA_API void  (lua_getfield) (lua_State *L, int idx, const char *k);LUA_API void  (lua_rawget) (lua_State *L, int idx);LUA_API void  (lua_rawgeti) (lua_State *L, int idx, int n);LUA_API void  (lua_createtable) (lua_State *L, int narr, int nrec);LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz);LUA_API int   (lua_getmetatable) (lua_State *L, int objindex);LUA_API void  (lua_getfenv) (lua_State *L, int idx);&#x2F;*** set functions (stack -&gt; Lua)*&#x2F;&#x2F;&#x2F;Lua获取栈中数据或修改栈中数据LUA_API void  (lua_settable) (lua_State *L, int idx);LUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);LUA_API void  (lua_rawset) (lua_State *L, int idx);LUA_API void  (lua_rawseti) (lua_State *L, int idx, int n);LUA_API int   (lua_setmetatable) (lua_State *L, int obj</code></pre><p>除此之外，还有一系列用来控制堆栈的相关函数（栈操作）：</p><pre class="language-c" data-language="c"><code class="language-c">&#x2F;*** basic stack manipulation*&#x2F;LUA_API int   (lua_gettop) (lua_State *L);LUA_API void  (lua_settop) (lua_State *L, int idx);LUA_API void  (lua_pushvalue) (lua_State *L, int idx);LUA_API void  (lua_remove) (lua_State *L, int idx);LUA_API void  (lua_insert) (lua_State *L, int idx);LUA_API void  (lua_replace) (lua_State *L, int idx);LUA_API int   (lua_checkstack) (lua_State *L, int sz);</code></pre><h3 id="C-C-调用Lua"><a href="#C-C-调用Lua" class="headerlink" title="C/C++调用Lua"></a><strong>C/C++调用Lua</strong></h3><p><strong>C/C++ 获取 Lua 值</strong></p><ol><li>使用 lua_getglobal 来获取值并将其压栈。</li><li>使用 lua_toXXX 将栈中元素取出（此时元素并不会出栈）转成相应的 C/C++ 类型的值。</li></ol><p><strong>C/C++ 调用 Lua 函数</strong></p><ol><li>使用 lua_getglobal 来获取函数并将其压栈。</li><li>如果这个函数有参数的话，就需要依次将函数的参数也压入栈。</li><li>调用 lua_pcall 开始调用函数，调用完成以后，会将返回值压入栈中。</li><li>取返回值，调用完毕。</li></ol><h3 id="Lua-调用-C-C"><a href="#Lua-调用-C-C" class="headerlink" title="Lua 调用 C/C++"></a><strong>Lua 调用 C/C++</strong></h3><p>Lua 可以调用 C/C++ 的函数，步骤为：</p><ol><li><code>将 C 的函数包装成 Lua 环境认可的函数</code>：将被调用的 C/C++ 函数从普通的 C/C++ 函数包装成 Lua_CFunction 格式，并需要在函数中将返回值压入栈中，并返回返回值个数;</li><li><code>将包装好的函数注册到 Lua 环境中</code>：使用宏<code>lua_register</code> 调用<code>lua_pushfunction(L,f)</code> 和<code>lua_setglobal(L,n)</code>，将函数存放在一个全局 table 中。</li><li>像使用普通 Lua 函数那样使用注册函数。</li></ol><p>PS：注意XLua或ToLua都是对Lua虚拟机做了上层封装，方便进行相关接口调用。</p><hr><h2 id="Lua的闭包（主要通过upValue实现）"><a href="#Lua的闭包（主要通过upValue实现）" class="headerlink" title="Lua的闭包（主要通过upValue实现）"></a>Lua的闭包（主要通过upValue实现）</h2><h3 id="Lua的闭包定义与使用"><a href="#Lua的闭包定义与使用" class="headerlink" title="Lua的闭包定义与使用"></a>Lua的闭包定义与使用</h3><p>闭包：<em><strong>能够读取其他函数内部变量的函数</strong></em>。</p><p>常见形式：通过调用含有一个内部函数加上该外部函数持有的外部局部变量（upvalue）的外部函数产生的一个函数实例。（外部函数+外部局部变量+内部函数（闭包函数））。</p><pre class="language-lua" data-language="lua"><code class="language-lua">function test()        local i&#x3D;0        return function()&#x2F;&#x2F;尾调用            i+&#x3D;1            return i        end    end    c1&#x3D;test()    c2&#x3D;test()--c1,c2是建立在同一个函数，同一个局部变量的不同实例上面的两个不同的闭包             --闭包中的upvalue各自独立，调用一次test（）就会产生一个新的闭包    print(c1()) --&gt;1    print(c1()) --&gt;2&#x2F;&#x2F;重复调用时每一个调用都会记住上一次调用后的值，就是说i&#x3D;1了已经    print(c2())    --&gt;1&#x2F;&#x2F;闭包不同所以upvalue不同    print(c2()) --&gt;2</code></pre><p>由上文输出结果可知：闭包中的外部局部变量在每个函数实例中各自独立，两个实例的调用结果不会相互干扰。同时实例中的外部局部变量会被保存。</p><p>PS：由于迭代器需要保存上一次调用的状态与下一次成功调用的状态，可以正好用闭包的机制实现。（迭代器只是一个生成器，本身不带有循环）以下是迭代器的实现。</p><pre class="language-lua" data-language="lua"><code class="language-lua">　 function list_iter(t)            local i&#x3D;0            local n&#x3D;table.getn(t)            return function()                i&#x3D;i+1                if i&lt;&#x3D;n then return t[i] end            end    end--使用t&#x3D;&#123;10,20,90&#125;            iter&#x3D;list_iter(t)--调用迭代器产生一个闭包while true dolocal element&#x3D;iter()    if element&#x3D;&#x3D;nil then break end       print(element)    endend--泛型for使用：t&#x3D;&#123;10,0,29&#125;            for element in list_iter(t) do                print(element)end--这里的list_iter()工厂函数只会被调用一次产生一个闭包函数，后面的每一次迭代都是用该闭包函数，而不是工厂函数</code></pre><h3 id="Lua闭包的底层实现"><a href="#Lua闭包的底层实现" class="headerlink" title="Lua闭包的底层实现"></a>Lua闭包的底层实现</h3><p>在Lua语言运行期间，任何时候只要 Lua执行一个 function…end 表达式， 它就会创建一个新的闭包。同时每个闭包会包含以下内容：</p><ul><li>一个对<code>函数原型proto</code>的引用</li><li>一个对<code>环境</code>的引用（环境其实是一个表，函数可在该表中索引全局变量）</li><li>一个数组，数组中每个元素都是一个对 <code>upvalue</code> 的引用，可通过该数组来存取外层的局部变量 （upvalue是proto中的一个信息，见上文）</li></ul><p>闭包最主要的特点是能够获取其他函数内部变量。Lua是通过<code>upvalue 的结构</code>来实现该功能的，对任何外层局部变量的存取都能间接地通过 upvalue 来进行。upvalue 最初指向栈中变量活跃的地方（图 4 左边） 。当离开变量作用域时（超过变量生存期时） ，变量被复制到 upvalue 中（图 4 右边） 。由于对变量的存取是通过 upvalue 里的指针间接进行的，因此复制动作对任何存取此变量的代码来说都是没有影响的。</p><p><img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled5.png" alt="Untitled"></p><p>与内层函数不同的是， 声明该局部变量的函数直接在堆栈中存取它的局部变量。<code>通过为每个变量至少创建一个 upvalue 并按所需情况进行重复利用</code>，保证了未决状态（是否超过生存期）的局部变量（pending vars）能够在闭包间正确地共享。<code>为了保证这种唯一性， Lua 为整个运行栈保存了一个链接着所有正打开着的 upvalue（那些当前正指向栈内局部变量的 upvalue）的链表</code>（图 4 中未决状态的局部变量的链表） 。当 Lua 创建一个新的闭包时，它开始遍历所有的外层局部变量，对于其中的每一个，若在上述 upvalue 链表中找到它，就重用此 upvalue，否则， Lua 将创建一个新的 upvalue 并加入链表中。注意，<code>一般情况下这种遍历过程在探查了少数几个节点后就结束了</code>， 因为对于每个被内层函数用到的外层局部变量来说，该链表至少包含一个与其对应的入口（upvalue） 。一旦某个关闭的upvalue 不再被任何闭包所引用，那么它的存储空间就立刻被回收。</p><p>一个函数有可能存取其更外层函数而非直接外层函数的局部变量。 这种情况下，有可能当闭包创建时，此局部变量尚不存在。 <code>Lua 使用 flat 闭包</code>来处理这种情况。<code>有了 flat 闭包，无论何时只要函数存取更外层的局部变量，该变量也会进入其直接外层函数的闭包中</code>。这样，当一个函数被实例化时，所有进入其闭包的变量就在直接外层函数的栈或闭包中了。</p><hr><h3 id="Lua的元表与元方法（面向对象）"><a href="#Lua的元表与元方法（面向对象）" class="headerlink" title="Lua的元表与元方法（面向对象）"></a>Lua的元表与元方法（面向对象）</h3><p>在Lua table中我们可以访问对应的key来得到value值，但是却无法对两个table进行操作。因此<code>Lua 提供了元表(Metatable)，允许我们改变table的行为，每个行为关联了对应的元方法</code>。通俗来说，元表就像是一个“操作指南”，里面包含了一系列操作的解决方案，例如__index方法就是定义了这个表在索引失败的情况下该怎么办，__add方法就是告诉table在相加的时候应该怎么做。这里面的__index，__add就是元方法。（上文table表的结构中可以看见元表与元方法标记）</p><h3 id="面向对象的实现"><a href="#面向对象的实现" class="headerlink" title="面向对象的实现"></a>面向对象的实现</h3><pre class="language-lua" data-language="lua"><code class="language-lua">--基类AccountAccount &#x3D; &#123;balance &#x3D; 0&#125;function Account:new (o)o &#x3D; o or &#123;&#125;setmetatable(o, self)&#x2F;&#x2F;设置元表为自身self.__index &#x3D; self&#x2F;&#x2F;设置__index元方法为自身return oendfunction Account:deposit (v)self.balance &#x3D; self.balance + vendfunction Account:withdraw (v)if v &gt; self.balance then error&quot;insufficient funds&quot; endself.balance &#x3D; self.balance - vend--子类SpecialAccount--此时代表SpecialAccount是Account的一个实例，即继承了Account所有内容SpecialAccount &#x3D; Account:new()--SpecialAccount从Account继承了new方法--new执行时，self指向SpecialAccount--s的metable，__index是SpecialAccounts &#x3D; SpecialAccount:new&#123;limit &#x3D; 1000.00&#125;&#x2F;&#x2F;s继承了SpecialAccount--在s中找不到deposit域，会到SpecialAccount找，然后到Account中找s:deposit(100.00)----------------------------------------------------------------------根据上面的描述，我们就可以在SpecialAccount中重写Account方法function SpecialAccount:withdraw (v)if v - self.balance &gt;&#x3D; self:getLimit() thenerror&quot;insufficient funds&quot;endself.balance &#x3D; self.balance - vendfunction SpecialAccount:getLimit ()return self.limit or 0end--调用方法 s:withdraw(200.00)，Lua 不会到 Account 中查找--因为它第一次就在 SpecialAccount 中发现了新的 withdraw 方法--由于 s.limit 等于 1000.00（记住我们创建 s 的时候初始化了这个值）--程序执行了取款操作，s 的 balance 变成了负值s:withdraw(200.00)</code></pre><hr><h2 id="Lua语言的GC算法"><a href="#Lua语言的GC算法" class="headerlink" title="Lua语言的GC算法"></a>Lua语言的GC算法</h2><h3 id="两种常见的垃圾回收算法"><a href="#两种常见的垃圾回收算法" class="headerlink" title="两种常见的垃圾回收算法"></a>两种常见的垃圾回收算法</h3><ul><li><strong>自动引用计数(Automatic Reference Counting)算法</strong>（<strong><strong>ARC算法</strong></strong>）<ul><li>对每一个对象保存一个整形的引用计数属性，用来记录对象被引用的情况，当记录对象被引用数维0时，将会被GC进行回收。</li><li>实现简单，判定效率高，回收没有延迟</li><li>单独的存储计数器字段，增加了存储空间的开销；每次赋值需要更新存储计数器增加了时间开销；<strong>无法处理循环引用问题</strong>（致命）</li><li>解决方法（Java）：可达性分析（不可达对象不等于无引用对象，最少要分析标记两次）</li></ul>  <img src="../Lua%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Untitled6.png" alt="Untitled"></li><li><strong><strong>标记-清除（Mark - Sweep）算法</strong></strong><ul><li>当堆中的有效内存空间被耗尽时，停止整个程序，进行标记工作与清除工作<ul><li>标记：<strong><strong>Collector</strong></strong>从根节点开始遍历，标记所有被引用对象。（一般在对象的Header中记录为可达对象）</li><li>清除：<strong><strong>Collector</strong></strong>对堆内存进行从头到尾的线性遍历，发现没有标记为可达对象的对象将其回收</li></ul></li><li>效率低，GC时需要停止整个用户进程，用户体验差，清理出的内存不连续没需要维护一个空闲链表</li></ul></li></ul><h3 id="Lua的GC原理与算法设计"><a href="#Lua的GC原理与算法设计" class="headerlink" title="Lua的GC原理与算法设计"></a>Lua的GC原理与算法设计</h3><ul><li>Lua语言的GC算法采用<code>标记-清除（Mark - Sweep）算法</code></li><li>在Lua5.1之前，Lua的GC过程是一次性不可打断的过程，采用的Mark算法是双色标记算法，黑色不被回收，白色被回收。但是如果在GC过程的回收阶段中，加入新的对象，不论标记成什么颜色都不对，所以在后来被改进</li><li>Lua5.1之后采用了分布回收（增量GC的实现）以及<code>三色增量标记清除算法</code>  更新之后的节点主要分为三种：<ul><li><strong>黑色节点</strong>：已经完全扫描过的节点。</li><li><strong>灰色节点</strong>：在扫描黑色节点时候初步扫描到，但是还未完全扫描的obj，这类obj会被放到一个待处理列表中进行逐个完全扫描。</li><li><strong>白色节点</strong>：还未被任何黑色节点所引用的节点(因为一旦被黑色节点引用将被置为黑色或灰色)。这里白色又被进一步细分为<strong>cur white</strong>和<strong>old white</strong>，lua会记录当前的<strong>cur white</strong>颜色，每个节点新创建的时候都是<strong>cur white</strong>，lua会在mark阶段结束的时候翻转这个<strong>cur white</strong>的位，从而使得这之前创建的白色节点都是<strong>old</strong>的，在sweep阶段能够得到正确释放。</li></ul></li></ul><p>GC的主要流程如下：</p><pre class="language-c" data-language="c"><code class="language-c">为每一个新创建的节点设置为cur white（当前白色）&#x2F;&#x2F;初始化阶段遍历root根节点的引用对象，将white（所有白色）设置成灰色，放入灰色节点链表中&#x2F;&#x2F;标记阶段（存在引用屏障，保证黑色节点不指向白色节点，灰色是屏障）循环扫描灰色链表中的元素，将其置为黑色，然后扫描与该元素关联的其他元素，白色置灰加入灰色节点链表结束回收阶段，将所有cur white的节点设置成old white的节点（保证这些节点都是要被回收的，回收阶段新加入的白色节点不回收）&#x2F;&#x2F;回收阶段（可能存在新的白色节点加入，设置为cur white）遍历所有对象，回收所有old white节点</code></pre><hr><h2 id="Lua语言的基础写法"><a href="#Lua语言的基础写法" class="headerlink" title="Lua语言的基础写法"></a>Lua语言的基础写法</h2><p>指路：<a href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程 | 菜鸟教程 (runoob.com)</a></p><hr><h2 id="参考文献与学习资料"><a href="#参考文献与学习资料" class="headerlink" title="参考文献与学习资料"></a>参考文献与学习资料</h2><ul><li><a href="https://blog.csdn.net/yuanlin2008/article/details/8486463">探索Lua5.2内部实现:编译系统(1) 概述_yuanlin2008的博客-CSDN博客</a></li><li><a href="https://www.lfzxb.top/the-theory-of-lua-5-0/">Lua5.0原理探究 | 登峰造极者，殊途亦同归。 (lfzxb.top)</a></li><li><a href="https://www.codingnow.com/2000/download/The%20Implementation%20of%20Lua5.0.pdf">The Implementation of Lua5.0.pdf (codingnow.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/454695276?utm_id=0">Lua 跨语言调用 - 知乎 (zhihu.com)</a></li><li>Brent论文提到的HashTable增查新方法 地址：<a href="https://maths-people.anu.edu.au/~brent/pd/rpb013.pdf">https://maths-people.anu.edu.au/~brent/pd/rpb013.pdf</a></li><li><a href="https://www.cnblogs.com/Jaysonhome/category/1557006.html">Lua相关 - 随笔分类 - 天山鸟 - 博客园 (cnblogs.com)</a></li><li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/v_xchen_v/article/details/77249332">https://link.zhihu.com/?target=https%3A//blog.csdn.net/v_xchen_v/article/details/77249332</a></li><li>《Lua的设计与实现》</li><li>《Lua5.3 王桂林》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity渲染顺序探究</title>
      <link href="/2023/09/05/Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/"/>
      <url>/2023/09/05/Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间在群里看见一个有关于求问Unity渲染透明物体与不透明物体渲染顺序的问题，有群友提到了深度与渲染顺序有关，就去找了相关资料学习，并在这里记录一下。</p><h3 id="Unity的UGUI层级渲染顺序管理"><a href="#Unity的UGUI层级渲染顺序管理" class="headerlink" title="Unity的UGUI层级渲染顺序管理"></a>Unity的UGUI层级渲染顺序管理</h3><p><img src="../Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/Untitled.png" alt="Untitled"></p><p>摄像机的Depth：值越大，渲染物体越靠上，<strong>摄像机会根据Depth从小到大的顺序，渲染各自Culling Mask的层。</strong></p><p>RenderQueue：渲染物体的透明度，小于2500的先渲染</p><p>SortingLayer：SortingLayer在Inspector面板中点击Tag -&gt; AddTag -&gt; SortingLayer，可以添加自定义的sortingLayer，默认的sortingLayer为Default</p><p>Order In Layer：SortingLayer中的内部渲染排序。</p><p><img src="../Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/Untitled1.png" alt="Untitled"></p><p><img src="../Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/Untitled2.png" alt="Untitled"></p><p>RectTransform.SetSiblingIndex：设置显示与渲染顺序，值越大，越靠上</p><ul><li>SetAsFirstSibling：移动到所有兄弟节点的第一个位置（Hierarchy同级最上面，先渲染，显示在最下面）</li><li>SetAsLastSibling：移动到所有兄弟节点的最后一个位置（Hierarchy同级最下面，后渲染，显示在最上面）</li><li>GetSiblingIndex：获得该元素在当前兄弟节点层级的位置</li><li>SetSiblingIndex：设置该元素在当前兄弟节点层级的位置</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 图形渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A*算法</title>
      <link href="/2023/08/06/A-%E7%AE%97%E6%B3%95/"/>
      <url>/2023/08/06/A-%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一种在静态路网中求解最短路径最有效的直接搜索算法。</p><hr><h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><p>F=G+H（f*(n)=g*(n)+h*(n)）</p><p>G：代表从起点A移动到指定方格的移动代价（路径长短）</p><p>H：代表从指定方格移动到终点B的移动代价（路径长短）</p><hr><h3 id="G点的计算"><a href="#G点的计算" class="headerlink" title="G点的计算"></a>G点的计算</h3><p>PS：需要使用到开放列表中父节点的应用</p><ul><li>假设角色横向与纵向的移动代价是10，对角线的移动代价是14（平方根）,。计算G值的方法就是找到父节点的G值，再根据横纵向，还是对角线为G值加上10或14。</li></ul><h3 id="H值的估算-Manhattan-方法：试探法"><a href="#H值的估算-Manhattan-方法：试探法" class="headerlink" title="H值的估算(Manhattan 方法：试探法)"></a>H值的估算(Manhattan 方法：试探法)</h3><p>PS：方法有很多不同的，可上网查找。</p><ul><li>计算从当前方格横向或纵向移动到达目标所经过的方格数，忽略对角移动，然后把总数乘以 10。</li></ul><h3 id="openlist（开放列表）与closelist（封闭列表）"><a href="#openlist（开放列表）与closelist（封闭列表）" class="headerlink" title="openlist（开放列表）与closelist（封闭列表）"></a>openlist（开放列表）与closelist（封闭列表）</h3><ul><li>openlist：记录所有被考虑来寻找最短路径的网格集合（经过路径的所有相邻节点逐渐加入该列表）</li><li>closelist：一个记录下不会被考虑的网格集合（已经被选中的路径点加入该列表）</li></ul><hr><p><img src="../A-%E7%AE%97%E6%B3%95/Untitled.png" alt="Untitled"></p><h3 id="寻路步骤："><a href="#寻路步骤：" class="headerlink" title="寻路步骤："></a>寻路步骤：</h3><ul><li>简化搜索区域，将搜索区域简化成2维数组，数组中每一项代表一个格子。状态分成可走与不可走。</li><li>从起点A开始，将其加入方格组成的openlist（开放列表）中，列表中的格子是路径可能会沿途经过的（有可能经过的方块格）。  <img src="../A-%E7%AE%97%E6%B3%95/Untitled1.png" alt="Untitled"></li><li>查找与A相邻的方格（忽略障碍物所在的格子），将所有可达的方格加入到openlist列表当中，并且将起点A设置成这些可达方格的父节点。</li><li>将方格A从openlist列表中移除，加入到closelist（封闭列表）当中。</li><li>根据公式计算，取出openlist表中F值最小的方格数据，放入closelist中。</li><li>检索该方格相邻的所有方格，忽略不可达以及在closelist中的方格，openlist中，并为加入的方格设置父节点。重复以上操作。</li><li>如果发现相邻的方格已经存在了openlist当中，就检查这条路径是否更优（是否具有更小的G值），没有则不作操作。如果 G 值更小，则把那个方格的父亲设为当前方格 ( 我们选中的方格 )，然后重新计算那个方格的 F 值和 G 值</li></ul><hr><h3 id="算法性能的提高"><a href="#算法性能的提高" class="headerlink" title="算法性能的提高"></a>算法性能的提高</h3><ul><li>可以再openlist表中保存好路径元素，并且对表中元素进行排序，这样每次取值只要取第一个方格的数据就行</li><li>使用二叉堆（快2~3倍）：<a href="http://www.policyalmanac.org/games/binaryHeaps.htm">Using Binary Heaps in A* Pathfinding</a></li><li>系列点子<ul><li>使用小地图或者更少的寻路者</li><li>千万不要同时给多个寻路者寻路。取而代之的是把它们放入队列中，分散到几个游戏周期中。</li><li>考虑在地图中使用更大的方格。这减少了寻路时需要搜索的方格数量。或长路径使用大方块，接近目标使用小方块。资料：<a href="http://www.policyalmanac.org/games/twoTiered.htm">Two-Tiered A* Pathfinding</a></li><li>对于很长的路径，考虑使用路径点系统，或者可以预先计算路径并加入游戏中。</li><li>预先处理你的地图，指出哪些区域是不可到达的。这些区域称为“孤岛”。A* 的下限是，你告诉他搜寻通往哪些区域的路径时，他会搜索整个地图，直到所有可以抵达的方格都通过 open list 或 close list 得到了处理。</li><li>不同的地形损耗，地形不是只有 2 种：可抵达的和不可抵达，不同的地形移动代价可以不同，沼泽，山丘，地牢的楼梯等等</li><li>influence Mapping：创建一个额外的计分系统，把它应用到寻路的 AI 中。地图上有个通道穿过山丘，有大批的寻路者要通过这个通道，电脑每次产生一个通过那个方格的路径都会变得很拥挤。如果需要，你可以产生一个 influence map，用来标记提高那些方格的移动代价，让电脑避开那个区域移动</li><li>采用布兰森汉姆算法预先判断两点是否可以直接通行,可通行就直接返回两点的直线路径,不可直接通行再采用A星算法寻路</li><li>A*算法走的是最小代价路径，但不一定是最平滑的路径。可以增加一个额外开销，作为允许G值的一定波动范围，然后查找相邻格子中最平滑的地方。</li></ul><hr>  github简单实例链接（没做优化版）：<a href="https://github.com/The-Black-Sun/Static_pathfinding_algorithm_A_Star">https://github.com/The-Black-Sun/Static_pathfinding_algorithm_A_Star</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 路径规划，性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
