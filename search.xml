<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unity渲染顺序探究</title>
      <link href="/2023/09/05/Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/"/>
      <url>/2023/09/05/Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间在群里看见一个有关于求问Unity渲染透明物体与不透明物体渲染顺序的问题，有群友提到了深度与渲染顺序有关，就去找了相关资料学习，并在这里记录一下。</p><h3 id="Unity的UGUI层级渲染顺序管理"><a href="#Unity的UGUI层级渲染顺序管理" class="headerlink" title="Unity的UGUI层级渲染顺序管理"></a>Unity的UGUI层级渲染顺序管理</h3><p><img src="../Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/Untitled.png" alt="Untitled"></p><p>摄像机的Depth：值越大，渲染物体越靠上，<strong>摄像机会根据Depth从小到大的顺序，渲染各自Culling Mask的层。</strong></p><p>RenderQueue：渲染物体的透明度，小于2500的先渲染</p><p>SortingLayer：SortingLayer在Inspector面板中点击Tag -&gt; AddTag -&gt; SortingLayer，可以添加自定义的sortingLayer，默认的sortingLayer为Default</p><p>Order In Layer：SortingLayer中的内部渲染排序。</p><p><img src="../Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/Untitled1.png" alt="Untitled"></p><p><img src="../Unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%A9%B6/Untitled2.png" alt="Untitled"></p><p>RectTransform.SetSiblingIndex：设置显示与渲染顺序，值越大，越靠上</p><ul><li>SetAsFirstSibling：移动到所有兄弟节点的第一个位置（Hierarchy同级最上面，先渲染，显示在最下面）</li><li>SetAsLastSibling：移动到所有兄弟节点的最后一个位置（Hierarchy同级最下面，后渲染，显示在最上面）</li><li>GetSiblingIndex：获得该元素在当前兄弟节点层级的位置</li><li>SetSiblingIndex：设置该元素在当前兄弟节点层级的位置</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 图形渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A*算法</title>
      <link href="/2023/08/06/A-%E7%AE%97%E6%B3%95/"/>
      <url>/2023/08/06/A-%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一种在静态路网中求解最短路径最有效的直接搜索算法。</p><hr><h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><p>F=G+H（f*(n)=g*(n)+h*(n)）</p><p>G：代表从起点A移动到指定方格的移动代价（路径长短）</p><p>H：代表从指定方格移动到终点B的移动代价（路径长短）</p><hr><h3 id="G点的计算"><a href="#G点的计算" class="headerlink" title="G点的计算"></a>G点的计算</h3><p>PS：需要使用到开放列表中父节点的应用</p><ul><li>假设角色横向与纵向的移动代价是10，对角线的移动代价是14（平方根）,。计算G值的方法就是找到父节点的G值，再根据横纵向，还是对角线为G值加上10或14。</li></ul><h3 id="H值的估算-Manhattan-方法：试探法"><a href="#H值的估算-Manhattan-方法：试探法" class="headerlink" title="H值的估算(Manhattan 方法：试探法)"></a>H值的估算(Manhattan 方法：试探法)</h3><p>PS：方法有很多不同的，可上网查找。</p><ul><li>计算从当前方格横向或纵向移动到达目标所经过的方格数，忽略对角移动，然后把总数乘以 10。</li></ul><h3 id="openlist（开放列表）与closelist（封闭列表）"><a href="#openlist（开放列表）与closelist（封闭列表）" class="headerlink" title="openlist（开放列表）与closelist（封闭列表）"></a>openlist（开放列表）与closelist（封闭列表）</h3><ul><li>openlist：记录所有被考虑来寻找最短路径的网格集合（经过路径的所有相邻节点逐渐加入该列表）</li><li>closelist：一个记录下不会被考虑的网格集合（已经被选中的路径点加入该列表）</li></ul><hr><p><img src="../A-%E7%AE%97%E6%B3%95/Untitled.png" alt="Untitled"></p><h3 id="寻路步骤："><a href="#寻路步骤：" class="headerlink" title="寻路步骤："></a>寻路步骤：</h3><ul><li>简化搜索区域，将搜索区域简化成2维数组，数组中每一项代表一个格子。状态分成可走与不可走。</li><li>从起点A开始，将其加入方格组成的openlist（开放列表）中，列表中的格子是路径可能会沿途经过的（有可能经过的方块格）。  <img src="../A-%E7%AE%97%E6%B3%95/Untitled1.png" alt="Untitled"></li><li>查找与A相邻的方格（忽略障碍物所在的格子），将所有可达的方格加入到openlist列表当中，并且将起点A设置成这些可达方格的父节点。</li><li>将方格A从openlist列表中移除，加入到closelist（封闭列表）当中。</li><li>根据公式计算，取出openlist表中F值最小的方格数据，放入closelist中。</li><li>检索该方格相邻的所有方格，忽略不可达以及在closelist中的方格，openlist中，并为加入的方格设置父节点。重复以上操作。</li><li>如果发现相邻的方格已经存在了openlist当中，就检查这条路径是否更优（是否具有更小的G值），没有则不作操作。如果 G 值更小，则把那个方格的父亲设为当前方格 ( 我们选中的方格 )，然后重新计算那个方格的 F 值和 G 值</li></ul><hr><h3 id="算法性能的提高"><a href="#算法性能的提高" class="headerlink" title="算法性能的提高"></a>算法性能的提高</h3><ul><li>可以再openlist表中保存好路径元素，并且对表中元素进行排序，这样每次取值只要取第一个方格的数据就行</li><li>使用二叉堆（快2~3倍）：<a href="http://www.policyalmanac.org/games/binaryHeaps.htm">Using Binary Heaps in A* Pathfinding</a></li><li>系列点子<ul><li>使用小地图或者更少的寻路者</li><li>千万不要同时给多个寻路者寻路。取而代之的是把它们放入队列中，分散到几个游戏周期中。</li><li>考虑在地图中使用更大的方格。这减少了寻路时需要搜索的方格数量。或长路径使用大方块，接近目标使用小方块。资料：<a href="http://www.policyalmanac.org/games/twoTiered.htm">Two-Tiered A* Pathfinding</a></li><li>对于很长的路径，考虑使用路径点系统，或者可以预先计算路径并加入游戏中。</li><li>预先处理你的地图，指出哪些区域是不可到达的。这些区域称为“孤岛”。A* 的下限是，你告诉他搜寻通往哪些区域的路径时，他会搜索整个地图，直到所有可以抵达的方格都通过 open list 或 close list 得到了处理。</li><li>不同的地形损耗，地形不是只有 2 种：可抵达的和不可抵达，不同的地形移动代价可以不同，沼泽，山丘，地牢的楼梯等等</li><li>influence Mapping：创建一个额外的计分系统，把它应用到寻路的 AI 中。地图上有个通道穿过山丘，有大批的寻路者要通过这个通道，电脑每次产生一个通过那个方格的路径都会变得很拥挤。如果需要，你可以产生一个 influence map，用来标记提高那些方格的移动代价，让电脑避开那个区域移动</li><li>采用布兰森汉姆算法预先判断两点是否可以直接通行,可通行就直接返回两点的直线路径,不可直接通行再采用A星算法寻路</li><li>A*算法走的是最小代价路径，但不一定是最平滑的路径。可以增加一个额外开销，作为允许G值的一定波动范围，然后查找相邻格子中最平滑的地方。</li></ul><hr>  github简单实例链接（没做优化版）：<a href="https://github.com/The-Black-Sun/Static_pathfinding_algorithm_A_Star">https://github.com/The-Black-Sun/Static_pathfinding_algorithm_A_Star</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 路径规划，性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
